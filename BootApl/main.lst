   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 115               	TimeOut:
   1:main.c        **** /*****************************************************************************
   2:main.c        **** *
   3:main.c        **** * AVRPROG compatible boot-loader
   4:main.c        **** * Version  : 0.85 (Dec. 2008)
   5:main.c        **** * Compiler : avr-gcc 4.1.2 / avr-libc 1.4.6
   6:main.c        **** * size     : depends on features and startup ( minmal features < 512 words)
   7:main.c        **** * by       : Martin Thomas, Kaiserslautern, Germany
   8:main.c        **** *            eversmith@heizung-thomas.de
   9:main.c        **** *            Additional code and improvements contributed by:
  10:main.c        **** *           - Uwe Bonnes
  11:main.c        **** *           - Bjoern Riemer
  12:main.c        **** *           - Olaf Rempel
  13:main.c        **** *
  14:main.c        **** * License  : Copyright (c) 2006-2008 M. Thomas, U. Bonnes, O. Rempel
  15:main.c        **** *            Free to use. You have to mention the copyright
  16:main.c        **** *            owners in source-code and documentation of derived
  17:main.c        **** *            work. No warranty! (Yes, you can insert the BSD
  18:main.c        **** *            license here)
  19:main.c        **** *
  20:main.c        **** * Tested with ATmega8, ATmega16, ATmega162, ATmega32, ATmega324P,
  21:main.c        **** *             ATmega644, ATmega644P, ATmega128, AT90CAN128
  22:main.c        **** *
  23:main.c        **** * - Initial versions have been based on the Butterfly bootloader-code
  24:main.c        **** *   by Atmel Corporation (Authors: BBrandal, PKastnes, ARodland, LHM)
  25:main.c        **** *
  26:main.c        **** ****************************************************************************
  27:main.c        **** *
  28:main.c        **** *  See the makefile and readme.txt for information on how to adapt 
  29:main.c        **** *  the linker-settings to the selected Boot Size (BOOTSIZE=xxxx) and 
  30:main.c        **** *  the MCU-type. Other configurations futher down in this file.
  31:main.c        **** *
  32:main.c        **** *  With BOOT_SIMPLE, minimal features and discarded int-vectors
  33:main.c        **** *  this bootloader has should fit into a a 512 word (1024, 0x400 bytes) 
  34:main.c        **** *  bootloader-section. 
  35:main.c        **** *
  36:main.c        **** ****************************************************************************/
  37:main.c        **** 
  38:main.c        **** /* Частота контроллера (кварца) */
  39:main.c        **** #ifndef F_CPU
  40:main.c        **** // #define F_CPU 7372800
  41:main.c        **** //#define F_CPU (7372800/2)
  42:main.c        **** #define F_CPU 8000000
  43:main.c        **** #endif
  44:main.c        **** 
  45:main.c        **** /* UART Скорость UART оптимально 19200 */
  46:main.c        **** //#define BAUDRATE 9600
  47:main.c        **** #define BAUDRATE 19200
  48:main.c        **** //#define BAUDRATE 115200
  49:main.c        **** 
  50:main.c        **** /* Режим двойной скорости UART (бит U2C)*/
  51:main.c        **** //#define UART_DOUBLESPEED
  52:main.c        **** 
  53:main.c        **** /* Используется второй UART на mega128 / can128 / mega162 / mega324p / mega644p */
  54:main.c        **** //#define UART_USE_SECOND
  55:main.c        **** 
  56:main.c        **** /* Тип устройства:
  57:main.c        ****    Для AVRProg выбирать BOOT 
  58:main.c        ****    Это корректное значение для bootloader.
  59:main.c        ****    avrdude может определить только part-code для ISP */
  60:main.c        **** #define DEVTYPE     DEVTYPE_BOOT
  61:main.c        **** // #define DEVTYPE     DEVTYPE_ISP
  62:main.c        **** 
  63:main.c        **** /*
  64:main.c        ****  * Выбор порта для кнопки входа в загрузчик
  65:main.c        ****  * Чтобы войти в загрузчик надо чтобы при запуске эта кнопка замыкала пин на землю
  66:main.c        ****  */
  67:main.c        **** #define BLPORT		PORTD
  68:main.c        **** #define BLDDR		DDRD
  69:main.c        **** #define BLPIN		PIND
  70:main.c        **** #define BLPNUM		PIND5
  71:main.c        **** 
  72:main.c        **** #define BL_2_PORT		PORTB
  73:main.c        **** #define BL_2_DDR		DDRB
  74:main.c        **** #define BL_2_PIN		PINB
  75:main.c        **** #define BL_2_PNUM		PINB7
  76:main.c        **** 
  77:main.c        **** #define RELE_PORT		PORTB
  78:main.c        **** #define RELE_DDR		DDRB
  79:main.c        **** #define RELE_PIN		PINB
  80:main.c        **** #define RELE_PNUM		PINB1
  81:main.c        **** 
  82:main.c        **** 
  83:main.c        **** /*
  84:main.c        ****  * Выбор порта для индикатора работы загрузчика
  85:main.c        ****  * Светодиод горит - мы в загрузчике
  86:main.c        ****  */
  87:main.c        **** 
  88:main.c        **** #define ENABLE_BOOT_LED
  89:main.c        **** #define BIPORT		PORTD
  90:main.c        **** #define BIDDR		DDRD
  91:main.c        **** #define BIPIN		PIND
  92:main.c        **** #define BIPNUM		PIND5
  93:main.c        **** 
  94:main.c        **** 
  95:main.c        **** /*
  96:main.c        ****  * Выключить Собачий таймер на время загрузчика
  97:main.c        ****  */
  98:main.c        **** #define DISABLE_WDT_AT_STARTUP
  99:main.c        **** 
 100:main.c        **** /*
 101:main.c        ****  * Watchdog-reset is issued at exit 
 102:main.c        ****  * define the timeout-value here (see avr-libc manual)
 103:main.c        ****  */
 104:main.c        **** #define EXIT_WDT_TIME   WDTO_250MS
 105:main.c        **** 
 106:main.c        **** /*
 107:main.c        ****  * Выбор режима загрузчика
 108:main.c        ****  * SIMPLE-Mode - Загрузчик стартует когда нажата его кнопка
 109:main.c        ****  *   переход к основной программе осуществляется после сброса 
 110:main.c        ****  *   (кнопка должна быть отжата) либо по команде от программатора
 111:main.c        ****  *   При этом режиме вывод на кнопку конфигурируется как вход-с подтягом,
 112:main.c        ****  *   но при выходе из загрузчика все выставляется по умолчанию
 113:main.c        ****  * POWERSAVE-Mode - Startup is separated in two loops
 114:main.c        ****  *   which makes power-saving a little easier if no firmware
 115:main.c        ****  *   is on the chip. Needs more memory
 116:main.c        ****  * BOOTICE-Mode - для зашивки  JTAGICE файла upgrade.ebn в Мегу16.
 117:main.c        ****  *   что превращает ее в JTAG отладчик. Разумеется нужно добавить весь необходимый
 118:main.c        ****  *   обвяз на кристалл для этого. И частота должна быть везде прописана как 7372800
 119:main.c        ****  *   в F_CPU Для совместимости с родной прошивкой JTAG ICE
 120:main.c        ****  * WAIT-mode Bootloader ожидает команды на вход, если ее не было в течении промежутка времени
 121:main.c        ****  *   (который настраивается) то проихсодит переход к основной программе.
 122:main.c        ****  */
 123:main.c        **** #define START_SIMPLE
 124:main.c        **** //#define START_WAIT
 125:main.c        **** //#define START_POWERSAVE
 126:main.c        **** //#define START_BOOTICE
 127:main.c        **** 
 128:main.c        **** /* Команда для входа в загрузчик в START_WAIT */
 129:main.c        **** #define START_WAIT_UARTCHAR 'S'
 130:main.c        **** 
 131:main.c        **** /* Выдержка для START_WAIT mode ( t = WAIT_TIME * 10ms ) */
 132:main.c        **** #define WAIT_VALUE 400 /* сейчас: 300*10ms = 3000ms = 3sec */
 133:main.c        **** #define TIME_OUT_VALUE 8
 134:main.c        **** #define CLR_CNT_TIME_OUT time_out = 0
 135:main.c        **** /*
 136:main.c        ****  * enable/disable readout of fuse and lock-bits
 137:main.c        ****  * (AVRPROG has to detect the AVR correctly by device-code
 138:main.c        ****  * to show the correct information).
 139:main.c        ****  */
 140:main.c        **** //#define ENABLEREADFUSELOCK
 141:main.c        **** 
 142:main.c        **** /* enable/disable write of lock-bits
 143:main.c        ****  * WARNING: lock-bits can not be reseted by bootloader (as far as I know)
 144:main.c        ****  * Only protection no unprotection, "chip erase" from bootloader only
 145:main.c        ****  * clears the flash but does no real "chip erase" (this is not possible
 146:main.c        ****  * with a bootloader as far as I know)
 147:main.c        ****  * Keep this undefined!
 148:main.c        ****  */
 149:main.c        **** //#define WRITELOCKBITS
 150:main.c        **** 
 151:main.c        **** /*
 152:main.c        ****  * define the following if the bootloader should not output
 153:main.c        ****  * itself at flash read (will fake an empty boot-section)
 154:main.c        ****  */
 155:main.c        **** //#define READ_PROTECT_BOOTLOADER 
 156:main.c        **** 
 157:main.c        **** #define VERSION_HIGH '0'
 158:main.c        **** #define VERSION_LOW  '8'
 159:main.c        **** 
 160:main.c        **** #define GET_LOCK_BITS           0x0001
 161:main.c        **** #define GET_LOW_FUSE_BITS       0x0000
 162:main.c        **** #define GET_HIGH_FUSE_BITS      0x0003
 163:main.c        **** #define GET_EXTENDED_FUSE_BITS  0x0002
 164:main.c        **** 
 165:main.c        **** /* Расчет делителя частоты для USART*/
 166:main.c        **** #ifdef UART_DOUBLESPEED
 167:main.c        **** 
 168:main.c        **** 	#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 4UL)) / ((uint32_
 169:main.c        **** 
 170:main.c        **** #else
 171:main.c        **** 
 172:main.c        **** 	#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 8UL)) / ((uint32_
 173:main.c        **** 
 174:main.c        **** #endif
 175:main.c        **** 
 176:main.c        **** 
 177:main.c        **** #include <stdint.h>
 178:main.c        **** #include <avr/io.h>
 179:main.c        **** #include <avr/wdt.h>
 180:main.c        **** #include <avr/boot.h>
 181:main.c        **** #include <avr/pgmspace.h>
 182:main.c        **** #include <avr/eeprom.h>
 183:main.c        **** #include <avr/interrupt.h>
 184:main.c        **** #include <util/delay.h>
 185:main.c        **** 
 186:main.c        **** #include "chipdef.h"
 187:main.c        **** 
 188:main.c        **** uint8_t gBuffer[SPM_PAGESIZE];
 189:main.c        **** uint8_t time_out;
 190:main.c        **** 
 191:main.c        **** static inline void TimeOut(void);
 192:main.c        **** 
 193:main.c        **** #if defined(BOOTLOADERHASNOVECTORS)
 194:main.c        **** 	#warning "This Bootloader does not link interrupt vectors - see makefile"
 195:main.c        **** 	/* make the linker happy - it wants to see __vector_default */
 196:main.c        **** 	// void __vector_default(void) { ; }
 197:main.c        **** 	void __vector_default(void) { ; }
 198:main.c        **** #endif
 199:main.c        **** 
 200:main.c        **** static void sendchar(uint8_t data)
 201:main.c        **** {
 202:main.c        **** 	CLR_CNT_TIME_OUT;
 203:main.c        **** 	while (!(UART_STATUS & (1<<UART_TXREADY)))
 204:main.c        **** 	{
 205:main.c        **** 		TimeOut();
 206:main.c        **** 	}
 207:main.c        **** 	UART_DATA = data;
 208:main.c        **** }
 209:main.c        **** 
 210:main.c        **** static uint8_t recvchar(void)
 211:main.c        **** {
 212:main.c        **** 	CLR_CNT_TIME_OUT;
 213:main.c        **** 	while (!(UART_STATUS & (1<<UART_RXREADY)))
 214:main.c        **** 	{
 215:main.c        **** 		TimeOut();
 216:main.c        **** 	}
 217:main.c        **** 	return UART_DATA;
 218:main.c        **** }
 219:main.c        **** 
 220:main.c        **** static inline void eraseFlash(void)
 221:main.c        **** {
 222:main.c        **** 	// erase only main section (bootloader protection)
 223:main.c        **** 	uint32_t addr = 0;
 224:main.c        **** 	while (APP_END > addr) 
 225:main.c        **** 		{
 226:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 227:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 228:main.c        **** 		addr += SPM_PAGESIZE;
 229:main.c        **** 		}
 230:main.c        **** 	boot_rww_enable();
 231:main.c        **** }
 232:main.c        **** 
 233:main.c        **** static inline void recvBuffer(pagebuf_t size)
 234:main.c        **** {
 235:main.c        **** 	pagebuf_t cnt;
 236:main.c        **** 	uint8_t *tmp = gBuffer;
 237:main.c        **** 
 238:main.c        **** 	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) 
 239:main.c        **** 		{
 240:main.c        **** 		*tmp++ = (cnt < size) ? recvchar() : 0xFF;
 241:main.c        **** 		}
 242:main.c        **** }
 243:main.c        **** 
 244:main.c        **** static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
 245:main.c        **** {
 246:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 247:main.c        **** 	uint32_t baddr = pagestart;
 248:main.c        **** 	uint16_t data;
 249:main.c        **** 	uint8_t *tmp = gBuffer;
 250:main.c        **** 
 251:main.c        **** 	do 
 252:main.c        **** 		{
 253:main.c        **** 		data = *tmp++;
 254:main.c        **** 		data |= *tmp++ << 8;
 255:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 256:main.c        **** 
 257:main.c        **** 		baddr += 2;			// Select next word in memory
 258:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 259:main.c        **** 		} 
 260:main.c        **** 	while (size);				// Loop until all bytes written
 261:main.c        **** 
 262:main.c        **** 	boot_page_write(pagestart);
 263:main.c        **** 	boot_spm_busy_wait();
 264:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 265:main.c        **** 
 266:main.c        **** 	return baddr>>1;
 267:main.c        **** }
 268:main.c        **** 
 269:main.c        **** 
 270:main.c        **** 
 271:main.c        **** static inline uint16_t readFlashPage(uint16_t waddr, pagebuf_t size)
 272:main.c        **** {
 273:main.c        **** 	uint32_t baddr = (uint32_t)waddr<<1;
 274:main.c        **** 	uint16_t data;
 275:main.c        **** 
 276:main.c        **** 	do 
 277:main.c        **** 	{
 278:main.c        **** 
 279:main.c        **** #ifndef READ_PROTECT_BOOTLOADER
 280:main.c        **** #warning "Bootloader not read-protected"
 281:main.c        **** 
 282:main.c        **** 	#if defined(RAMPZ)
 283:main.c        **** 		data = pgm_read_word_far(baddr);
 284:main.c        **** 	#else
 285:main.c        **** 		data = pgm_read_word_near(baddr);
 286:main.c        **** 	#endif
 287:main.c        **** 
 288:main.c        **** #else
 289:main.c        **** 		// don't read bootloader
 290:main.c        **** 		if ( baddr < APP_END ) 
 291:main.c        **** 		{
 292:main.c        **** 		#if defined(RAMPZ)
 293:main.c        **** 			data = pgm_read_word_far(baddr);
 294:main.c        **** 		#else
 295:main.c        **** 			data = pgm_read_word_near(baddr);
 296:main.c        **** 		#endif
 297:main.c        **** 		}
 298:main.c        **** 		else 
 299:main.c        **** 		{
 300:main.c        **** 		data = 0xFFFF; // fake empty
 301:main.c        **** 		}
 302:main.c        **** #endif
 303:main.c        **** 		sendchar(data);			// send LSB
 304:main.c        **** 		sendchar((data >> 8));		// send MSB
 305:main.c        **** 		baddr += 2;			// Select next word in memory
 306:main.c        **** 		size -= 2;			// Subtract two bytes from number of bytes to read
 307:main.c        **** 	} 
 308:main.c        **** 	while (size);				// Repeat until block has been read
 309:main.c        **** 	return baddr>>1;
 310:main.c        **** }
 311:main.c        **** 
 312:main.c        **** #if defined(ENABLEREADFUSELOCK)
 313:main.c        **** static uint8_t read_fuse_lock(uint16_t addr)
 314:main.c        **** {
 315:main.c        **** 	uint8_t mode = (1<<BLBSET) | (1<<SPMEN);
 316:main.c        **** 	uint8_t retval;
 317:main.c        **** 
 318:main.c        **** 	asm volatile
 319:main.c        **** 	(
 320:main.c        **** 		"movw r30, %3\n\t"		/* Z to addr */ \
 321:main.c        **** 		"sts %0, %2\n\t"		/* set mode in SPM_REG */ \
 322:main.c        **** 		"lpm\n\t"			/* load fuse/lock value into r0 */ \
 323:main.c        **** 		"mov %1,r0\n\t"			/* save return value */ \
 324:main.c        **** 		: "=m" (SPM_REG),
 325:main.c        **** 		  "=r" (retval)
 326:main.c        **** 		: "r" (mode),
 327:main.c        **** 		  "r" (addr)
 328:main.c        **** 		: "r30", "r31", "r0"
 329:main.c        **** 	);
 330:main.c        **** 	return retval;
 331:main.c        **** }
 332:main.c        **** #endif
 333:main.c        **** 
 334:main.c        **** static void send_boot(void)
 335:main.c        **** {
 336:main.c        **** 	sendchar('A');
 337:main.c        **** 	sendchar('V');
 338:main.c        **** 	sendchar('R');
 339:main.c        **** 	sendchar('B');
 340:main.c        **** 	sendchar('O');
 341:main.c        **** 	sendchar('O');
 342:main.c        **** 	sendchar('T');
 343:main.c        **** }
 344:main.c        **** 
 345:main.c        **** static void (*jump_to_app)(void) = 0x0000;
 346:main.c        **** 
 347:main.c        **** int main(void)
 348:main.c        **** {
 349:main.c        **** 	uint16_t address = 0;
 350:main.c        **** 	uint8_t device = 0, val;
 351:main.c        **** 
 352:main.c        **** 
 353:main.c        **** 
 354:main.c        **** #ifdef ENABLE_BOOT_LED	// LED ON
 355:main.c        **** 	BIPORT |= (1<<BIPNUM);	
 356:main.c        **** 	BIDDR  |= (1<<BIPNUM);
 357:main.c        **** #endif
 358:main.c        **** 
 359:main.c        **** 
 360:main.c        **** #ifdef DISABLE_WDT_AT_STARTUP
 361:main.c        **** 	#ifdef WDT_OFF_SPECIAL
 362:main.c        **** 		#warning "using target specific watchdog_off"
 363:main.c        **** 		bootloader_wdt_off();
 364:main.c        **** 	#else
 365:main.c        **** 		cli();
 366:main.c        **** 		wdt_reset();
 367:main.c        **** 		wdt_disable();
 368:main.c        **** 	#endif
 369:main.c        **** #endif
 370:main.c        **** 	
 371:main.c        **** #ifdef START_POWERSAVE
 372:main.c        **** 	uint8_t OK = 1;
 373:main.c        **** #endif
 374:main.c        **** 
 375:main.c        **** 	RELE_DDR  |=  (1<<RELE_PNUM);		// set as Output
 376:main.c        **** 	RELE_PORT &= ~(1<<RELE_PNUM);		// Rele turn off
 377:main.c        **** 
 378:main.c        **** 	BLDDR  &= ~(1<<BLPNUM);		// set as Input
 379:main.c        **** 	BLPORT |= (1<<BLPNUM);		// Enable pullup
 380:main.c        **** 	
 381:main.c        **** 	BL_2_DDR  &= ~(1<<BL_2_PNUM);		// set as Input
 382:main.c        **** 	BL_2_PORT |= (1<<BL_2_PNUM);		// Enable pullup
 383:main.c        **** 
 384:main.c        **** 	// Set baud rate
 385:main.c        **** 	UART_BAUD_HIGH = (UART_CALC_BAUDRATE(BAUDRATE)>>8) & 0xFF;
 386:main.c        **** 	UART_BAUD_LOW = (UART_CALC_BAUDRATE(BAUDRATE) & 0xFF);
 387:main.c        **** 
 388:main.c        **** #ifdef UART_DOUBLESPEED
 389:main.c        **** 	UART_STATUS = ( 1<<UART_DOUBLE );
 390:main.c        **** #endif
 391:main.c        **** 
 392:main.c        **** 	UART_CTRL = UART_CTRL_DATA;
 393:main.c        **** 	UART_CTRL2 = UART_CTRL2_DATA;
 394:main.c        **** 	
 395:main.c        **** #if defined(START_POWERSAVE)
 396:main.c        **** 	/*
 397:main.c        **** 		This is an adoption of the Butterfly Bootloader startup-sequence.
 398:main.c        **** 		It may look a little strange but separating the login-loop from
 399:main.c        **** 		the main parser-loop gives a lot a possibilities (timeout, sleep-modes
 400:main.c        **** 	    etc.).
 401:main.c        **** 	*/
 402:main.c        **** 	for(;OK;) 
 403:main.c        **** 	{
 404:main.c        **** 		if ((BLPIN & (1<<BLPNUM))) 
 405:main.c        **** 		{
 406:main.c        **** 		// jump to main app if pin is not grounded
 407:main.c        **** 		BLPORT &= ~(1<<BLPNUM);	// set to default
 408:main.c        **** 
 409:main.c        **** 		#ifdef UART_DOUBLESPEED
 410:main.c        **** 			UART_STATUS &= ~( 1<<UART_DOUBLE );
 411:main.c        **** 		#endif
 412:main.c        **** 
 413:main.c        **** 
 414:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 415:main.c        **** 		BIPORT &= ~(1<<BIPNUM);	
 416:main.c        **** 		BIDDR  &= ~(1<<BIPNUM);
 417:main.c        **** 		#endif
 418:main.c        **** 
 419:main.c        **** 		jump_to_app();		// Jump to application sector
 420:main.c        **** 
 421:main.c        **** 		} 
 422:main.c        **** 		else 
 423:main.c        **** 		{
 424:main.c        **** 		val = recvchar();
 425:main.c        **** 		/* ESC */
 426:main.c        **** 			if (val == 0x1B) 
 427:main.c        **** 			{
 428:main.c        **** 				// AVRPROG connection
 429:main.c        **** 				// Wait for signon
 430:main.c        **** 				while (val != 'S')
 431:main.c        **** 				val = recvchar();
 432:main.c        **** 				
 433:main.c        **** 				send_boot();			// Report signon
 434:main.c        **** 				OK = 0;
 435:main.c        **** 			} 
 436:main.c        **** 			else 
 437:main.c        **** 			{
 438:main.c        **** 			sendchar('?');
 439:main.c        **** 			}
 440:main.c        **** 	    }
 441:main.c        **** 		// Power-Save code here
 442:main.c        **** 	}
 443:main.c        **** 
 444:main.c        **** #elif defined(START_SIMPLE)
 445:main.c        **** 	uint16_t cnt = 0;
 446:main.c        **** 	uint16_t cnt_key;
 447:main.c        **** 	
 448:main.c        **** 	cnt_key = 0;
 449:main.c        **** 	for(cnt = 0; cnt < WAIT_VALUE; cnt++)
 450:main.c        **** 	{
 451:main.c        **** 		if ((BLPIN & (1<<BLPNUM)) && (BL_2_PIN & (1<<BL_2_PNUM))) 
 452:main.c        **** 		{
 453:main.c        **** 			cnt_key++;
 454:main.c        **** 		}
 455:main.c        **** 		_delay_ms(1);
 456:main.c        **** 	}
 457:main.c        **** 	if (cnt_key > (WAIT_VALUE - (WAIT_VALUE/2))) 
 458:main.c        **** 	{
 459:main.c        **** 		// jump to main app if pin is not grounded
 460:main.c        **** 			
 461:main.c        **** 	#ifdef UART_DOUBLESPEED
 462:main.c        **** 		UART_STATUS &= ~( 1<<UART_DOUBLE );
 463:main.c        **** 	#endif
 464:main.c        **** 
 465:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 466:main.c        **** 		BIPORT &= ~(1<<BIPNUM);	
 467:main.c        **** 		BIDDR  &= ~(1<<BIPNUM);
 468:main.c        **** 		#endif
 469:main.c        **** 
 470:main.c        **** 		jump_to_app();			// Jump to application sector
 471:main.c        **** 	}
 472:main.c        **** 
 473:main.c        **** #elif defined(START_WAIT)
 474:main.c        **** 
 475:main.c        **** 	uint16_t cnt = 0;
 476:main.c        **** 
 477:main.c        **** 	while (1) {
 478:main.c        **** 		if (UART_STATUS & (1<<UART_RXREADY))
 479:main.c        **** 			if (UART_DATA == START_WAIT_UARTCHAR)
 480:main.c        **** 				break;
 481:main.c        **** 
 482:main.c        **** 		if (cnt++ >= WAIT_VALUE) {
 483:main.c        **** 			BLPORT &= ~(1<<BLPNUM);		// set to default
 484:main.c        **** 
 485:main.c        **** 
 486:main.c        **** 			#ifdef ENABLE_BOOT_LED	// LED OFF
 487:main.c        **** 			BIPORT &= ~(1<<BIPNUM);	
 488:main.c        **** 			BIDDR  &= ~(1<<BIPNUM);
 489:main.c        **** 			#endif
 490:main.c        **** 			jump_to_app();			// Jump to application sector
 491:main.c        **** 		}
 492:main.c        **** 
 493:main.c        **** 		_delay_ms(10);
 494:main.c        **** 	}
 495:main.c        **** 	send_boot();
 496:main.c        **** 
 497:main.c        **** #elif defined(START_BOOTICE)
 498:main.c        **** #warning "BOOTICE mode - no startup-condition"
 499:main.c        **** 
 500:main.c        **** #else
 501:main.c        **** #error "Select START_ condition for bootloader in main.c"
 502:main.c        **** #endif
 503:main.c        **** 
 504:main.c        **** 
 505:main.c        **** 	for(;;) 
 506:main.c        **** 	{
 507:main.c        **** 		val = recvchar();
 508:main.c        **** 		// Autoincrement?
 509:main.c        **** 		if (val == 'a') 
 510:main.c        **** 		{
 511:main.c        **** 			sendchar('Y');			// Autoincrement is quicker
 512:main.c        **** 
 513:main.c        **** 		//write address
 514:main.c        **** 		} 
 515:main.c        **** 		else if (val == 'A') 
 516:main.c        **** 		{
 517:main.c        **** 			address = recvchar();		//read address 8 MSB
 518:main.c        **** 			address = (address<<8) | recvchar();
 519:main.c        **** 			sendchar('\r');
 520:main.c        **** 
 521:main.c        **** 		// Buffer load support
 522:main.c        **** 		} 
 523:main.c        **** 		else if (val == 'b') 
 524:main.c        **** 		{
 525:main.c        **** 			sendchar('Y');					// Report buffer load supported
 526:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 527:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 528:main.c        **** 
 529:main.c        **** 		// Start buffer load
 530:main.c        **** 		} 
 531:main.c        **** 		else if (val == 'B') 
 532:main.c        **** 		{
 533:main.c        **** 			pagebuf_t size;
 534:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 535:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 536:main.c        **** 			val = recvchar();				// Load memory type ('E' or 'F')
 537:main.c        **** 			recvBuffer(size);
 538:main.c        **** 
 539:main.c        **** 			if (device == DEVTYPE) 
 540:main.c        **** 			{
 541:main.c        **** 				if (val == 'F') 
 542:main.c        **** 				{
 543:main.c        **** 				address = writeFlashPage(address, size);
 544:main.c        **** 				} 
 545:main.c        **** 				else if (val == 'E') 
 546:main.c        **** 				{
 547:main.c        **** 				//address = writeEEpromPage(address, size);
 548:main.c        **** 				}
 549:main.c        **** 				sendchar('\r');
 550:main.c        **** 			} 
 551:main.c        **** 			else 
 552:main.c        **** 			{
 553:main.c        **** 			sendchar(0);
 554:main.c        **** 			}
 555:main.c        **** 
 556:main.c        **** 		// Block read
 557:main.c        **** 		} 
 558:main.c        **** 		else if (val == 'g') 
 559:main.c        **** 		{
 560:main.c        **** 			pagebuf_t size;
 561:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 562:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 563:main.c        **** 			val = recvchar();				// Get memtype
 564:main.c        **** 
 565:main.c        **** 			if (val == 'F') 
 566:main.c        **** 			{
 567:main.c        **** 			address = readFlashPage(address, size);
 568:main.c        **** 			} 
 569:main.c        **** 			else if (val == 'E') 
 570:main.c        **** 			{
 571:main.c        **** 			//address = readEEpromPage(address, size);
 572:main.c        **** 			}
 573:main.c        **** 
 574:main.c        **** 		// Chip erase
 575:main.c        ****  		} 
 576:main.c        **** 		else if (val == 'e') 
 577:main.c        **** 		{
 578:main.c        **** 		if (device == DEVTYPE) 
 579:main.c        **** 			{
 580:main.c        **** 			eraseFlash();
 581:main.c        **** 			}
 582:main.c        **** 		sendchar('\r');
 583:main.c        **** 
 584:main.c        **** 		// Exit upgrade
 585:main.c        **** 		} 
 586:main.c        **** 		else if (val == 'E') 
 587:main.c        **** 		{
 588:main.c        **** 		wdt_enable(EXIT_WDT_TIME); // Enable Watchdog Timer to give reset
 589:main.c        **** 		sendchar('\r');
 590:main.c        **** 
 591:main.c        **** 		#ifdef WRITELOCKBITS
 592:main.c        **** 			#warning "Extension 'WriteLockBits' enabled"
 593:main.c        **** 			// TODO: does not work reliably
 594:main.c        **** 			// write lockbits
 595:main.c        **** 			} 
 596:main.c        **** 			else if (val == 'l') 
 597:main.c        **** 			{
 598:main.c        **** 			if (device == DEVTYPE) 
 599:main.c        **** 				{
 600:main.c        **** 				// write_lock_bits(recvchar());
 601:main.c        **** 				boot_lock_bits_set(recvchar());	// boot.h takes care of mask
 602:main.c        **** 				boot_spm_busy_wait();
 603:main.c        **** 				}
 604:main.c        **** 			sendchar('\r');
 605:main.c        **** 		#endif
 606:main.c        **** 		// Enter programming mode
 607:main.c        **** 		} 
 608:main.c        **** 		else if (val == 'P') 
 609:main.c        **** 		{
 610:main.c        **** 		sendchar('\r');
 611:main.c        **** 
 612:main.c        **** 		// Leave programming mode
 613:main.c        **** 		} 
 614:main.c        **** 		else if (val == 'L') 
 615:main.c        **** 		{
 616:main.c        **** 		sendchar('\r');
 617:main.c        **** 		// return programmer type
 618:main.c        **** 		} 
 619:main.c        **** 		else if (val == 'p') 
 620:main.c        **** 		{
 621:main.c        **** 		sendchar('S');		// always serial programmer
 622:main.c        **** 
 623:main.c        **** 		#ifdef ENABLEREADFUSELOCK
 624:main.c        **** 			#warning "Extension 'ReadFuseLock' enabled"
 625:main.c        **** 			// read "low" fuse bits
 626:main.c        **** 			} 
 627:main.c        **** 			else if (val == 'F') 
 628:main.c        **** 			{
 629:main.c        **** 			sendchar(read_fuse_lock(GET_LOW_FUSE_BITS));
 630:main.c        **** 
 631:main.c        **** 			// read lock bits
 632:main.c        **** 			} 
 633:main.c        **** 			else if (val == 'r') 
 634:main.c        **** 			{
 635:main.c        **** 			sendchar(read_fuse_lock(GET_LOCK_BITS));
 636:main.c        **** 
 637:main.c        **** 			// read high fuse bits
 638:main.c        **** 			} 
 639:main.c        **** 			else if (val == 'N') 
 640:main.c        **** 			{
 641:main.c        **** 			sendchar(read_fuse_lock(GET_HIGH_FUSE_BITS));
 642:main.c        **** 			// read extended fuse bits
 643:main.c        **** 			} 
 644:main.c        **** 			else if (val == 'Q') 
 645:main.c        **** 			{
 646:main.c        **** 			sendchar(read_fuse_lock(GET_EXTENDED_FUSE_BITS));
 647:main.c        **** 			#endif
 648:main.c        **** 
 649:main.c        **** 		// Return device type
 650:main.c        **** 		} 
 651:main.c        **** 		else if (val == 't') 
 652:main.c        **** 		{
 653:main.c        **** 		sendchar(DEVTYPE);
 654:main.c        **** 		sendchar(0);
 655:main.c        **** 		// clear and set LED ignored
 656:main.c        **** 		} 
 657:main.c        **** 		else if ((val == 'x') || (val == 'y')) 
 658:main.c        **** 		{
 659:main.c        **** 		recvchar();
 660:main.c        **** 		sendchar('\r');
 661:main.c        **** 
 662:main.c        **** 		// set device
 663:main.c        **** 		} 
 664:main.c        **** 		else if (val == 'T') 
 665:main.c        **** 		{
 666:main.c        **** 		device = recvchar();
 667:main.c        **** 		sendchar('\r');
 668:main.c        **** 		// Return software identifier
 669:main.c        **** 		} 
 670:main.c        **** 		else if (val == 'S') 
 671:main.c        **** 		{
 672:main.c        **** 		send_boot();
 673:main.c        **** 
 674:main.c        **** 		// Return Software Version
 675:main.c        **** 		} 
 676:main.c        **** 		else if (val == 'V') {
 677:main.c        **** 		sendchar(VERSION_HIGH);
 678:main.c        **** 		sendchar(VERSION_LOW);
 679:main.c        **** 
 680:main.c        **** 		// Return Signature Bytes (it seems that 
 681:main.c        **** 		// AVRProg expects the "Atmel-byte" 0x1E last
 682:main.c        **** 		// but shows it first in the dialog-window)
 683:main.c        **** 		} 
 684:main.c        **** 		else if (val == 's') 
 685:main.c        **** 		{
 686:main.c        **** 		sendchar(SIG_BYTE3);
 687:main.c        **** 		sendchar(SIG_BYTE2);
 688:main.c        **** 		sendchar(SIG_BYTE1);
 689:main.c        **** 
 690:main.c        **** 		/* ESC */
 691:main.c        **** 		} 
 692:main.c        **** 		else if(val != 0x1b) 
 693:main.c        **** 		{
 694:main.c        **** 		sendchar('?');
 695:main.c        **** 		}
 696:main.c        **** 	} 
 697:main.c        **** 	return 0;
 698:main.c        **** }
 699:main.c        **** 
 700:main.c        **** static inline void TimeOut(void)
 701:main.c        **** {
 117               	.LM0:
 118               	.LFBB1:
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 702:main.c        **** 	TCCR1B = (1<<CS12 | 1<<CS10); // start with div 1024
 124               	.LM1:
 125 0000 85E0      		ldi r24,lo8(5)
 126 0002 8EBD      		out 0x2e,r24
 703:main.c        **** 	if(TIFR & (1 << TOV1))
 128               	.LM2:
 129 0004 08B6      		in __tmp_reg__,0x38
 130 0006 02FE      		sbrs __tmp_reg__,2
 131 0008 00C0      		rjmp .L1
 704:main.c        **** 	{
 705:main.c        **** 		TIFR = 0;
 133               	.LM3:
 134 000a 18BE      		out 0x38,__zero_reg__
 706:main.c        **** 		if (time_out++ > TIME_OUT_VALUE)
 136               	.LM4:
 137 000c 8091 0000 		lds r24,time_out
 138 0010 91E0      		ldi r25,lo8(1)
 139 0012 980F      		add r25,r24
 140 0014 9093 0000 		sts time_out,r25
 141 0018 8930      		cpi r24,lo8(9)
 142 001a 00F0      		brlo .L1
 143               	.LBB13:
 707:main.c        **** 		{
 708:main.c        **** 			TCCR1B = 0;
 145               	.LM5:
 146 001c 1EBC      		out 0x2e,__zero_reg__
 709:main.c        **** 			TIMSK  = 0;
 148               	.LM6:
 149 001e 19BE      		out 0x39,__zero_reg__
 710:main.c        **** 			jump_to_app();		// Jump to application sector
 151               	.LM7:
 152 0020 E0E0      		ldi r30,0
 153 0022 F0E0      		ldi r31,0
 154 0024 0994      		ijmp
 155               	.L1:
 156 0026 0895      		ret
 157               	.LBE13:
 159               	.Lscope1:
 162               	recvchar:
 211:main.c        **** 	CLR_CNT_TIME_OUT;
 164               	.LM8:
 165               	.LFBB2:
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 0 */
 169               	.L__stack_usage = 0
 212:main.c        **** 	while (!(UART_STATUS & (1<<UART_RXREADY)))
 171               	.LM9:
 172 0028 1092 0000 		sts time_out,__zero_reg__
 173               	.L7:
 213:main.c        **** 	{
 175               	.LM10:
 176 002c 5F99      		sbic 0xb,7
 177 002e 00C0      		rjmp .L9
 215:main.c        **** 	}
 179               	.LM11:
 180 0030 00D0      		rcall TimeOut
 181 0032 00C0      		rjmp .L7
 182               	.L9:
 217:main.c        **** }
 184               	.LM12:
 185 0034 8CB1      		in r24,0xc
 218:main.c        **** 
 187               	.LM13:
 188 0036 0895      		ret
 190               	.Lscope2:
 194               	sendchar:
 201:main.c        **** 	CLR_CNT_TIME_OUT;
 196               	.LM14:
 197               	.LFBB3:
 198 0038 CF93      		push r28
 199 003a DF93      		push r29
 200 003c 1F92      		push __zero_reg__
 201 003e CDB7      		in r28,__SP_L__
 202 0040 DEB7      		in r29,__SP_H__
 203               	/* prologue: function */
 204               	/* frame size = 1 */
 205               	/* stack size = 3 */
 206               	.L__stack_usage = 3
 202:main.c        **** 	while (!(UART_STATUS & (1<<UART_TXREADY)))
 208               	.LM15:
 209 0042 1092 0000 		sts time_out,__zero_reg__
 210               	.L11:
 203:main.c        **** 	{
 212               	.LM16:
 213 0046 5D99      		sbic 0xb,5
 214 0048 00C0      		rjmp .L13
 205:main.c        **** 	}
 216               	.LM17:
 217 004a 8983      		std Y+1,r24
 218 004c 00D0      		rcall TimeOut
 219 004e 8981      		ldd r24,Y+1
 220 0050 00C0      		rjmp .L11
 221               	.L13:
 207:main.c        **** }
 223               	.LM18:
 224 0052 8CB9      		out 0xc,r24
 225               	/* epilogue start */
 208:main.c        **** 
 227               	.LM19:
 228 0054 0F90      		pop __tmp_reg__
 229 0056 DF91      		pop r29
 230 0058 CF91      		pop r28
 231 005a 0895      		ret
 233               	.Lscope3:
 235               	.global	__vector_default
 237               	__vector_default:
 197:main.c        **** #endif
 239               	.LM20:
 240               	.LFBB4:
 241               	/* prologue: function */
 242               	/* frame size = 0 */
 243               	/* stack size = 0 */
 244               	.L__stack_usage = 0
 245 005c 0895      		ret
 247               	.Lscope4:
 248               		.section	.text.startup,"ax",@progbits
 250               	.global	main
 252               	main:
 348:main.c        **** 	uint16_t address = 0;
 254               	.LM21:
 255               	.LFBB5:
 256               	/* prologue: function */
 257               	/* frame size = 0 */
 258               	/* stack size = 0 */
 259               	.L__stack_usage = 0
 355:main.c        **** 	BIDDR  |= (1<<BIPNUM);
 261               	.LM22:
 262 0000 959A      		sbi 0x12,5
 356:main.c        **** #endif
 264               	.LM23:
 265 0002 8D9A      		sbi 0x11,5
 365:main.c        **** 		wdt_reset();
 267               	.LM24:
 268               	/* #APP */
 269               	 ;  365 "main.c" 1
 270 0004 F894      		cli
 271               	 ;  0 "" 2
 366:main.c        **** 		wdt_disable();
 273               	.LM25:
 274               	 ;  366 "main.c" 1
 275 0006 A895      		wdr
 276               	 ;  0 "" 2
 277               	/* #NOAPP */
 278               	.LBB33:
 279               	.LBB34:
 281               	.Ltext1:
   1:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    All rights reserved.
   4:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
   5:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
   8:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    * Redistributions of source code must retain the above copyright
   9:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  11:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****      the documentation and/or other materials provided with the
  14:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****      distribution.
  15:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  16:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****      contributors may be used to endorse or promote products derived
  18:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****      from this software without specific prior written permission.
  19:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  20:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  32:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /* $Id$ */
  33:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  34:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /*
  35:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****  */
  37:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  38:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #ifndef _AVR_WDT_H_
  39:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define _AVR_WDT_H_
  40:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  41:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #include <avr/io.h>
  42:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #include <stdint.h>
  43:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  44:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /** \file */
  45:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  48:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     This header file declares the interface to some inline macros
  49:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     to prevent the watchdog timer configuration from being
  51:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     accidentally altered by a crashing application, a special timed
  52:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     sequence is required in order to change it.  The macros within
  53:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     this header file handle the required sequence automatically
  54:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     the manipulation.
  56:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  57:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     \note Depending on the fuse configuration of the particular
  58:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     device, further restrictions might apply, in particular it might
  59:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     be disallowed to turn off the watchdog timer.
  60:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  61:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     timer remains active even after a system reset (except a power-on
  64:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     the following:
  68:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  69:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     \code
  70:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     #include <stdint.h>
  71:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     #include <avr/wdt.h>
  72:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  73:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  75:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     void get_mcusr(void) \
  76:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       __attribute__((naked)) \
  77:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       __attribute__((section(".init3")));
  78:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     void get_mcusr(void)
  79:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     {
  80:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       mcusr_mirror = MCUSR;
  81:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       MCUSR = 0;
  82:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       wdt_disable();
  83:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     }
  84:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     \endcode
  85:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  86:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     clearing the watchdog reset flag before disabling the
  89:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     watchdog is required, according to the datasheet.
  90:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** */
  91:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  92:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /**
  93:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    \ingroup avr_watchdog
  94:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    a call to this instruction is required before the timer expires,
  96:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** */
  98:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  99:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 101:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 102:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #if defined(WDP3)
 103:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 104:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #else
 105:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** # define _WD_PS3_MASK       0x00
 106:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #endif
 107:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 108:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #if defined(WDTCSR)
 109:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 110:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #elif defined(WDTCR)
 111:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 112:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #else
 113:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #  define _WD_CONTROL_REG     WDT
 114:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #endif
 115:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 116:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #if defined(WDTOE)
 117:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 118:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #else
 119:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define _WD_CHANGE_BIT      WDCE
 120:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #endif
 121:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 122:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 123:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /**
 124:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    \ingroup avr_watchdog
 125:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 126:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 127:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 128:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 129:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    through \c WDP3 bits).
 130:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 131:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 132:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** */
 133:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 134:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 135:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #if defined(__AVR_XMEGA__)
 136:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 137:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 138:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 139:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_enable(timeout) \
 140:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** do { \
 141:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** uint8_t temp; \
 142:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __asm__ __volatile__ ( \
 143:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"wdr"									"\n\t" \
 144:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 145:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 146:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 147:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 148:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 149:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 150:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"rjmp 1b"								"\n\t" \
 151:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	: [tmp]					"=r" (temp) \
 152:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 153:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 154:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 155:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 156:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 157:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 158:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ); \
 159:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** } while(0)
 160:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 161:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_disable() \
 162:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** do { \
 163:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** uint8_t temp; \
 164:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __asm__ __volatile__ (  \
 165:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"wdr"								"\n\t" \
 166:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 167:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 168:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 169:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 170:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [tmp]            "=r" (temp) \
 171:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 172:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 173:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 174:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 175:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ); \
 176:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** } while(0)
 177:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 178:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 179:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 180:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /*
 181:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    wdt_enable(timeout) for xmega devices
 182:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 183:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    registers to the CCP register
 184:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ** At the same time,
 185:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 186:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 187:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    3) set timeout (timeout)
 188:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 189:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 190:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    sync is finished).
 191:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** */
 192:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_enable(timeout) \
 193:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** do { \
 194:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** uint8_t temp; \
 195:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __asm__ __volatile__ (         \
 196:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 197:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 198:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 199:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 200:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 201:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 202:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "rjmp 1b"                               "\n\t" \
 203:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 204:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [tmp]                "=r" (temp) \
 205:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 206:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 207:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 208:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 209:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 210:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 211:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 212:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : "r0" \
 213:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ); \
 214:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** } while(0)
 215:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 216:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_disable() \
 217:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __asm__ __volatile__ (  \
 218:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 219:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 220:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 221:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 222:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 223:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : \
 224:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 225:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 226:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 227:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 228:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 229:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : "r0" \
 230:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** );
 231:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 232:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 233:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 234:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #elif defined(__AVR_TINY__)
 235:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 236:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_enable(value) \
 237:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __asm__ __volatile__ ( \
 238:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 239:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "cli" "\n\t"  \
 240:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "wdr" "\n\t"  \
 241:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 242:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 243:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 244:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : /* no outputs */  \
 245:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 246:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 247:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 248:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 249:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 250:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : "r16" \
 251:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** )
 252:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 253:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_disable() \
 254:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** do { \
 255:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** uint8_t temp_wd; \
 256:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __asm__ __volatile__ ( \
 257:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 258:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "cli" "\n\t"  \
 259:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "wdr" "\n\t"  \
 260:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 261:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 262:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 263:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 264:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 265:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : /*no output */ \
 266:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 267:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 268:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 269:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 270:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 271:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : "r16" \
 272:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ); \
 273:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** }while(0)
 274:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 275:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #elif defined(CCP)
 276:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 277:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** static __inline__
 278:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __attribute__ ((__always_inline__))
 279:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** void wdt_enable (const uint8_t value)
 280:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** {
 281:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 282:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 283:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 284:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 285:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"cli" "\n\t"
 286:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"wdr" "\n\t"
 287:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 288:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 289:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 290:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: /* no outputs */
 291:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 292:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 293:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 294:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 295:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 296:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: "r0"
 297:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			);
 298:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 299:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 300:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 301:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 302:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 303:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"cli" "\n\t"
 304:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"wdr" "\n\t"
 305:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 306:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 307:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 308:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: /* no outputs */
 309:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 310:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 311:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 312:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 313:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 314:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: "r0"
 315:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			);
 316:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 317:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 318:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 319:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 320:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 321:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"cli" "\n\t"
 322:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"wdr" "\n\t"
 323:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 324:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 325:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 326:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: /* no outputs */
 327:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 328:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 329:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 330:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 331:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 332:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: "r0"
 333:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			);
 334:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 335:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else
 336:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****  	{
 337:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 338:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 339:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"cli" "\n\t"
 340:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"wdr" "\n\t"
 341:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 342:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 343:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 344:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: /* no outputs */
 345:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 346:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 347:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 348:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 349:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 350:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: "r0"
 351:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			);
 352:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 353:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** }
 354:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 355:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** static __inline__
 356:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __attribute__ ((__always_inline__))
 357:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** void wdt_disable (void)
 358:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** {
 359:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 360:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 361:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         uint8_t temp_wd;
 362:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         __asm__ __volatile__ (
 363:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 364:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cli" "\n\t"
 365:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"wdr" "\n\t"
 366:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 367:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 368:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 369:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 370:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 371:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: /*no output */
 372:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 373:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 374:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 375:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 376:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 377:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "r0"
 378:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				);
 379:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 380:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 381:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 382:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         uint8_t temp_wd;
 383:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         __asm__ __volatile__ (
 384:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 385:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cli" "\n\t"
 386:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"wdr" "\n\t"
 387:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 388:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 389:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 390:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 391:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 392:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: /*no output */
 393:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 394:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 395:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 396:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 397:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 398:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "r0"
 399:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				);
 400:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 401:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 402:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 403:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         uint8_t temp_wd;
 404:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         __asm__ __volatile__ (
 405:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 406:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cli" "\n\t"
 407:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"wdr" "\n\t"
 408:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 409:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 410:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 411:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 412:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 413:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: /*no output */
 414:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 415:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 416:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 417:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 418:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 419:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "r0"
 420:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				);
 421:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 422:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else
 423:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 424:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         uint8_t temp_wd;
 425:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         __asm__ __volatile__ (
 426:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 427:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cli" "\n\t"
 428:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"wdr" "\n\t"
 429:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 430:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 431:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 432:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 433:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 434:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: /*no output */
 435:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 436:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 437:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 438:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 439:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 440:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "r0"
 441:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				);
 442:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 443:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** }
 444:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 445:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #else
 446:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 447:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** static __inline__
 448:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __attribute__ ((__always_inline__))
 449:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** void wdt_enable (const uint8_t value)
 450:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** {
 451:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 452:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 453:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 454:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 455:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cli" "\n\t"
 456:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"wdr" "\n\t"
 457:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out %0, %1" "\n\t"
 458:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 459:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out %0, %2" "\n \t"
 460:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: /* no outputs */
 461:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 462:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 463:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 464:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 465:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "r0"
 466:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		);
 467:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 468:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else
 469:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 470:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 471:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 472:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cli" "\n\t"
 473:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"wdr" "\n\t"
 474:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"sts %0, %1" "\n\t"
 475:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 476:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"sts %0, %2" "\n \t"
 477:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: /* no outputs */
 478:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 479:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 480:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 481:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 482:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "r0"
 483:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		);
 484:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 485:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** }
 486:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 487:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** static __inline__
 488:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __attribute__ ((__always_inline__))
 489:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** void wdt_disable (void)
 490:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** {
 491:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 492:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 493:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         uint8_t register temp_reg;
 494:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 283               	.LM26:
 284               	/* #APP */
 285               	 ;  494 "e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\
 286 0008 0FB6      		in __tmp_reg__,__SREG__
 287 000a F894      		cli
 288 000c A895      		wdr
 289 000e 81B5      		in  r24,33
 290 0010 8861      		ori r24,24
 291 0012 81BD      		out 33,r24
 292 0014 11BC      		out 33,__zero_reg__
 293 0016 0FBE      		out __SREG__,__tmp_reg__
 294               		
 295               	 ;  0 "" 2
 296               	/* #NOAPP */
 297               	.LBE34:
 298               	.LBE33:
 300               	.Ltext2:
 375:main.c        **** 	RELE_PORT &= ~(1<<RELE_PNUM);		// Rele turn off
 302               	.LM27:
 303 0018 B99A      		sbi 0x17,1
 376:main.c        **** 
 305               	.LM28:
 306 001a C198      		cbi 0x18,1
 378:main.c        **** 	BLPORT |= (1<<BLPNUM);		// Enable pullup
 308               	.LM29:
 309 001c 8D98      		cbi 0x11,5
 379:main.c        **** 	
 311               	.LM30:
 312 001e 959A      		sbi 0x12,5
 381:main.c        **** 	BL_2_PORT |= (1<<BL_2_PNUM);		// Enable pullup
 314               	.LM31:
 315 0020 BF98      		cbi 0x17,7
 382:main.c        **** 
 317               	.LM32:
 318 0022 C79A      		sbi 0x18,7
 385:main.c        **** 	UART_BAUD_LOW = (UART_CALC_BAUDRATE(BAUDRATE) & 0xFF);
 320               	.LM33:
 321 0024 10BC      		out 0x20,__zero_reg__
 386:main.c        **** 
 323               	.LM34:
 324 0026 89E1      		ldi r24,lo8(25)
 325 0028 89B9      		out 0x9,r24
 392:main.c        **** 	UART_CTRL2 = UART_CTRL2_DATA;
 327               	.LM35:
 328 002a 88E1      		ldi r24,lo8(24)
 329 002c 8AB9      		out 0xa,r24
 393:main.c        **** 	
 331               	.LM36:
 332 002e 86E8      		ldi r24,lo8(-122)
 333 0030 80BD      		out 0x20,r24
 334 0032 E0E9      		ldi r30,lo8(-112)
 335 0034 F1E0      		ldi r31,lo8(1)
 448:main.c        **** 	for(cnt = 0; cnt < WAIT_VALUE; cnt++)
 337               	.LM37:
 338 0036 80E0      		ldi r24,0
 339 0038 90E0      		ldi r25,0
 340               	.L17:
 451:main.c        **** 		{
 342               	.LM38:
 343 003a 859B      		sbis 0x10,5
 344 003c 00C0      		rjmp .L16
 451:main.c        **** 		{
 346               	.LM39:
 347 003e B799      		sbic 0x16,7
 453:main.c        **** 		}
 349               	.LM40:
 350 0040 0196      		adiw r24,1
 351               	.L16:
 352               	.LBB35:
 353               	.LBB36:
 355               	.Ltext3:
   1:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define __HAS_DELAY_CYCLES 1
  40:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  41:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  42:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  43:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  44:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  45:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  46:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  47:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  49:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  51:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  52:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  53:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  54:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  55:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  58:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  59:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  60:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  62:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  64:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  65:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  67:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  68:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  69:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  71:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  73:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  74:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  75:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  76:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  77:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  78:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  79:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  81:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  82:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  84:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  87:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  88:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  89:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  90:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
  92:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  93:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  94:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
  95:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  97:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  98:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 101:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 102:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 103:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 104:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 105:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 106:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 107:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 109:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 110:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 112:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 114:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 115:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 119:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 120:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 123:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 124:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 125:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    the user gets atleast __us microseconds of delay.
 128:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    to round down and round to closest integer.
 131:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 132:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Also, the backward compatible
 136:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    required for rounding are not available to the compiler then.
 139:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 140:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 141:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 142:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 143:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 144:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ; 
 145:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 148:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 149:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 155:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 158:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 159:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 160:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 162:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 163:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 357               	.LM41:
 358 0042 AFEC      		ldi r26,lo8(1999)
 359 0044 B7E0      		ldi r27,hi8(1999)
 360 0046 1197      	1:	sbiw r26,1
 361 0048 01F4      		brne 1b
 362 004a 00C0      		rjmp .
 363 004c 0000      		nop
 364 004e 3197      		sbiw r30,1
 365               	.LBE36:
 366               	.LBE35:
 368               	.Ltext4:
 449:main.c        **** 	{
 370               	.LM42:
 371 0050 01F4      		brne .L17
 457:main.c        **** 	{
 373               	.LM43:
 374 0052 893C      		cpi r24,-55
 375 0054 9105      		cpc r25,__zero_reg__
 376 0056 00F0      		brlo .L18
 466:main.c        **** 		BIDDR  &= ~(1<<BIPNUM);
 378               	.LM44:
 379 0058 9598      		cbi 0x12,5
 467:main.c        **** 		#endif
 381               	.LM45:
 382 005a 8D98      		cbi 0x11,5
 470:main.c        **** 	}
 384               	.LM46:
 385 005c 0995      		icall
 386               	.L18:
 448:main.c        **** 	for(cnt = 0; cnt < WAIT_VALUE; cnt++)
 388               	.LM47:
 389 005e 10E0      		ldi r17,0
 390 0060 C0E0      		ldi r28,0
 391 0062 D0E0      		ldi r29,0
 392               	.LBB37:
 393               	.LBB38:
 395               	.Ltext5:
 453:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 397               	.LM48:
 398 0064 08E1      		ldi r16,lo8(24)
 399 0066 B02E      		mov r11,r16
 400 0068 8CE0      		ldi r24,lo8(12)
 401 006a A82E      		mov r10,r24
 402               	.LBE38:
 403               	.LBE37:
 404               	.LBB40:
 405               	.LBB41:
 407               	.Ltext6:
 226:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 409               	.LM49:
 410 006c 93E0      		ldi r25,lo8(3)
 411 006e 992E      		mov r9,r25
 230:main.c        **** }
 413               	.LM50:
 414 0070 01E1      		ldi r16,lo8(17)
 415               	.LBE41:
 416               	.LBE40:
 417               	.LBB43:
 418               	.LBB44:
 419               	.LBB45:
 255:main.c        **** 
 421               	.LM51:
 422 0072 8824      		clr r8
 423 0074 8394      		inc r8
 262:main.c        **** 	boot_spm_busy_wait();
 425               	.LM52:
 426 0076 25E0      		ldi r18,lo8(5)
 427 0078 222E      		mov r2,r18
 428               	.L19:
 429               	.LBE45:
 430               	.LBE44:
 431               	.LBE43:
 507:main.c        **** 		// Autoincrement?
 433               	.LM53:
 434 007a 00D0      		rcall recvchar
 509:main.c        **** 		{
 436               	.LM54:
 437 007c 8136      		cpi r24,lo8(97)
 438 007e 01F4      		brne .L20
 511:main.c        **** 
 440               	.LM55:
 441 0080 89E5      		ldi r24,lo8(89)
 442 0082 00C0      		rjmp .L61
 443               	.L20:
 515:main.c        **** 		{
 445               	.LM56:
 446 0084 8134      		cpi r24,lo8(65)
 447 0086 01F4      		brne .L22
 517:main.c        **** 			address = (address<<8) | recvchar();
 449               	.LM57:
 450 0088 00D0      		rcall recvchar
 451 008a C82F      		mov r28,r24
 452 008c D0E0      		ldi r29,0
 518:main.c        **** 			sendchar('\r');
 454               	.LM58:
 455 008e DC2F      		mov r29,r28
 456 0090 CC27      		clr r28
 457 0092 00D0      		rcall recvchar
 458 0094 C82B      		or r28,r24
 459 0096 00C0      		rjmp .L62
 460               	.L22:
 523:main.c        **** 		{
 462               	.LM59:
 463 0098 8236      		cpi r24,lo8(98)
 464 009a 01F4      		brne .L23
 525:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 466               	.LM60:
 467 009c 89E5      		ldi r24,lo8(89)
 468 009e 00D0      		rcall sendchar
 526:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 470               	.LM61:
 471 00a0 80E0      		ldi r24,0
 472 00a2 00D0      		rcall sendchar
 527:main.c        **** 
 474               	.LM62:
 475 00a4 80E4      		ldi r24,lo8(64)
 476 00a6 00C0      		rjmp .L61
 477               	.L23:
 531:main.c        **** 		{
 479               	.LM63:
 480 00a8 8234      		cpi r24,lo8(66)
 481 00aa 01F0      		breq .+2
 482 00ac 00C0      		rjmp .L24
 483               	.LBB50:
 534:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 485               	.LM64:
 486 00ae 00D0      		rcall recvchar
 535:main.c        **** 			val = recvchar();				// Load memory type ('E' or 'F')
 488               	.LM65:
 489 00b0 00D0      		rcall recvchar
 490 00b2 582E      		mov r5,r24
 536:main.c        **** 			recvBuffer(size);
 492               	.LM66:
 493 00b4 00D0      		rcall recvchar
 494 00b6 382E      		mov r3,r24
 495 00b8 A0E0      		ldi r26,lo8(gBuffer)
 496 00ba EA2E      		mov r14,r26
 497 00bc A0E0      		ldi r26,hi8(gBuffer)
 498 00be FA2E      		mov r15,r26
 499               	.LBB47:
 500               	.LBB48:
 238:main.c        **** 		{
 502               	.LM67:
 503 00c0 412C      		mov r4,__zero_reg__
 504               	.L26:
 240:main.c        **** 		}
 506               	.LM68:
 507 00c2 4514      		cp r4,r5
 508 00c4 00F4      		brsh .L48
 509 00c6 00D0      		rcall recvchar
 510 00c8 00C0      		rjmp .L25
 511               	.L48:
 512 00ca 8FEF      		ldi r24,lo8(-1)
 513               	.L25:
 514 00cc F701      		movw r30,r14
 515 00ce 8193      		st Z+,r24
 516 00d0 7F01      		movw r14,r30
 238:main.c        **** 		{
 518               	.LM69:
 519 00d2 4394      		inc r4
 520 00d4 F0E4      		ldi r31,lo8(64)
 521 00d6 4F12      		cpse r4,r31
 522 00d8 00C0      		rjmp .L26
 523               	.LBE48:
 524               	.LBE47:
 539:main.c        **** 			{
 526               	.LM70:
 527 00da 1737      		cpi r17,lo8(119)
 528 00dc 01F0      		breq .+2
 529 00de 00C0      		rjmp .L63
 541:main.c        **** 				{
 531               	.LM71:
 532 00e0 26E4      		ldi r18,lo8(70)
 533 00e2 3212      		cpse r3,r18
 534 00e4 00C0      		rjmp .L62
 535               	.LBB49:
 536               	.LBB46:
 246:main.c        **** 	uint32_t baddr = pagestart;
 538               	.LM72:
 539 00e6 CE01      		movw r24,r28
 540 00e8 A0E0      		ldi r26,0
 541 00ea B0E0      		ldi r27,0
 542 00ec 6C01      		movw r12,r24
 543 00ee 7D01      		movw r14,r26
 544 00f0 CC0C      		lsl r12
 545 00f2 DD1C      		rol r13
 546 00f4 EE1C      		rol r14
 547 00f6 FF1C      		rol r15
 249:main.c        **** 
 549               	.LM73:
 550 00f8 2091 0000 		lds r18,gBuffer
 247:main.c        **** 	uint16_t data;
 552               	.LM74:
 553 00fc B701      		movw r22,r14
 554 00fe A601      		movw r20,r12
 249:main.c        **** 
 556               	.LM75:
 557 0100 A0E0      		ldi r26,lo8(gBuffer)
 558 0102 B0E0      		ldi r27,hi8(gBuffer)
 559               	.L30:
 560 0104 1296      		adiw r26,2
 561 0106 FD01      		movw r30,r26
 562 0108 3197      		sbiw r30,1
 254:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 564               	.LM76:
 565 010a 8081      		ld r24,Z
 566 010c 30E0      		ldi r19,0
 567 010e 382B      		or r19,r24
 255:main.c        **** 
 569               	.LM77:
 570 0110 FA01      		movw r30,r20
 571               	/* #APP */
 572               	 ;  255 "main.c" 1
 573 0112 0901      		movw  r0, r18
 574 0114 8092 5700 		sts 87, r8
 575 0118 E895      		spm
 576 011a 1124      		clr  r1
 577               		
 578               	 ;  0 "" 2
 257:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 580               	.LM78:
 581               	/* #NOAPP */
 582 011c 4E5F      		subi r20,-2
 583 011e 5F4F      		sbci r21,-1
 584 0120 6F4F      		sbci r22,-1
 585 0122 7F4F      		sbci r23,-1
 586 0124 20E0      		ldi r18,lo8(gBuffer)
 587 0126 30E0      		ldi r19,hi8(gBuffer)
 588 0128 2A1B      		sub r18,r26
 589 012a 822F      		mov r24,r18
 590 012c 850D      		add r24,r5
 260:main.c        **** 
 592               	.LM79:
 593 012e 01F0      		breq .L29
 254:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 595               	.LM80:
 596 0130 2C91      		ld r18,X
 597 0132 00C0      		rjmp .L30
 598               	.L29:
 262:main.c        **** 	boot_spm_busy_wait();
 600               	.LM81:
 601 0134 F601      		movw r30,r12
 602               	/* #APP */
 603               	 ;  262 "main.c" 1
 604 0136 2092 5700 		sts 87, r2
 605 013a E895      		spm
 606               		
 607               	 ;  0 "" 2
 608               	/* #NOAPP */
 609               	.L31:
 263:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 611               	.LM82:
 612 013c 07B6      		in __tmp_reg__,0x37
 613 013e 00FC      		sbrc __tmp_reg__,0
 614 0140 00C0      		rjmp .L31
 264:main.c        **** 
 616               	.LM83:
 617               	/* #APP */
 618               	 ;  264 "main.c" 1
 619 0142 0093 5700 		sts 87, r16
 620 0146 E895      		spm
 621               		
 622               	 ;  0 "" 2
 266:main.c        **** }
 624               	.LM84:
 625               	/* #NOAPP */
 626 0148 7695      		lsr r23
 627 014a 6795      		ror r22
 628 014c 5795      		ror r21
 629 014e 4795      		ror r20
 630 0150 EA01      		movw r28,r20
 631               	.LBE46:
 632               	.LBE49:
 633 0152 00C0      		rjmp .L62
 634               	.L24:
 635               	.LBE50:
 558:main.c        **** 		{
 637               	.LM85:
 638 0154 8736      		cpi r24,lo8(103)
 639 0156 01F4      		brne .L32
 640               	.LBB51:
 561:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 642               	.LM86:
 643 0158 00D0      		rcall recvchar
 562:main.c        **** 			val = recvchar();				// Get memtype
 645               	.LM87:
 646 015a 00D0      		rcall recvchar
 647 015c F82E      		mov r15,r24
 563:main.c        **** 
 649               	.LM88:
 650 015e 00D0      		rcall recvchar
 565:main.c        **** 			{
 652               	.LM89:
 653 0160 8634      		cpi r24,lo8(70)
 654 0162 01F0      		breq .+2
 655 0164 00C0      		rjmp .L19
 656               	.LBB52:
 657               	.LBB53:
 273:main.c        **** 	uint16_t data;
 659               	.LM90:
 660 0166 CE01      		movw r24,r28
 661 0168 A0E0      		ldi r26,0
 662 016a B0E0      		ldi r27,0
 663 016c 2C01      		movw r4,r24
 664 016e 3D01      		movw r6,r26
 665 0170 440C      		lsl r4
 666 0172 551C      		rol r5
 667 0174 661C      		rol r6
 668 0176 771C      		rol r7
 669 0178 CF2D      		mov r28,r15
 670 017a C40D      		add r28,r4
 671               	.L33:
 672               	.LBB54:
 285:main.c        **** 	#endif
 674               	.LM91:
 675 017c F201      		movw r30,r4
 676               	/* #APP */
 677               	 ;  285 "main.c" 1
 678 017e E590      		lpm r14, Z+
 679 0180 F490      		lpm r15, Z
 680               		
 681               	 ;  0 "" 2
 682               	/* #NOAPP */
 683               	.LBE54:
 303:main.c        **** 		sendchar((data >> 8));		// send MSB
 685               	.LM92:
 686 0182 8E2D      		mov r24,r14
 687 0184 00D0      		rcall sendchar
 304:main.c        **** 		baddr += 2;			// Select next word in memory
 689               	.LM93:
 690 0186 8F2D      		mov r24,r15
 691 0188 00D0      		rcall sendchar
 305:main.c        **** 		size -= 2;			// Subtract two bytes from number of bytes to read
 693               	.LM94:
 694 018a F2E0      		ldi r31,2
 695 018c 4F0E      		add r4,r31
 696 018e 511C      		adc r5,__zero_reg__
 697 0190 611C      		adc r6,__zero_reg__
 698 0192 711C      		adc r7,__zero_reg__
 308:main.c        **** 	return baddr>>1;
 700               	.LM95:
 701 0194 C411      		cpse r28,r4
 702 0196 00C0      		rjmp .L33
 309:main.c        **** }
 704               	.LM96:
 705 0198 D301      		movw r26,r6
 706 019a C201      		movw r24,r4
 707 019c B695      		lsr r27
 708 019e A795      		ror r26
 709 01a0 9795      		ror r25
 710 01a2 8795      		ror r24
 711 01a4 EC01      		movw r28,r24
 712               	.LBE53:
 713               	.LBE52:
 714 01a6 00C0      		rjmp .L19
 715               	.L32:
 716               	.LBE51:
 576:main.c        **** 		{
 718               	.LM97:
 719 01a8 8536      		cpi r24,lo8(101)
 720 01aa 01F4      		brne .L34
 578:main.c        **** 			{
 722               	.LM98:
 723 01ac 1737      		cpi r17,lo8(119)
 724 01ae 01F0      		breq .+2
 725 01b0 00C0      		rjmp .L62
 726 01b2 E0E0      		ldi r30,0
 727 01b4 F0E0      		ldi r31,0
 728               	.L37:
 729               	.LBB55:
 730               	.LBB42:
 226:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 732               	.LM99:
 733               	/* #APP */
 734               	 ;  226 "main.c" 1
 735 01b6 9092 5700 		sts 87, r9
 736 01ba E895      		spm
 737               		
 738               	 ;  0 "" 2
 739               	/* #NOAPP */
 740               	.L36:
 227:main.c        **** 		addr += SPM_PAGESIZE;
 742               	.LM100:
 743 01bc 07B6      		in __tmp_reg__,0x37
 744 01be 00FC      		sbrc __tmp_reg__,0
 745 01c0 00C0      		rjmp .L36
 746 01c2 E05C      		subi r30,-64
 747 01c4 FF4F      		sbci r31,-1
 224:main.c        **** 		{
 749               	.LM101:
 750 01c6 E115      		cp r30,__zero_reg__
 751 01c8 2CE1      		ldi r18,28
 752 01ca F207      		cpc r31,r18
 753 01cc 01F4      		brne .L37
 230:main.c        **** }
 755               	.LM102:
 756               	/* #APP */
 757               	 ;  230 "main.c" 1
 758 01ce 0093 5700 		sts 87, r16
 759 01d2 E895      		spm
 760               		
 761               	 ;  0 "" 2
 762               	/* #NOAPP */
 763 01d4 00C0      		rjmp .L62
 764               	.L34:
 765               	.LBE42:
 766               	.LBE55:
 586:main.c        **** 		{
 768               	.LM103:
 769 01d6 8534      		cpi r24,lo8(69)
 770 01d8 01F4      		brne .L38
 771               	.LBB56:
 772               	.LBB39:
 774               	.Ltext7:
 453:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 776               	.LM104:
 777               	/* #APP */
 778               	 ;  453 "e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\
 779 01da 0FB6      		in __tmp_reg__,__SREG__
 780 01dc F894      		cli
 781 01de A895      		wdr
 782 01e0 B1BC      		out 33, r11
 783 01e2 0FBE      		out __SREG__,__tmp_reg__
 784 01e4 A1BC      		out 33, r10
 785               	 	
 786               	 ;  0 "" 2
 787               	/* #NOAPP */
 788 01e6 00C0      		rjmp .L62
 789               	.L38:
 790               	.LBE39:
 791               	.LBE56:
 793               	.Ltext8:
 608:main.c        **** 		{
 795               	.LM105:
 796 01e8 8035      		cpi r24,lo8(80)
 797 01ea 01F0      		breq .L62
 614:main.c        **** 		{
 799               	.LM106:
 800 01ec 8C34      		cpi r24,lo8(76)
 801 01ee 01F0      		breq .L62
 619:main.c        **** 		{
 803               	.LM107:
 804 01f0 8037      		cpi r24,lo8(112)
 805 01f2 01F4      		brne .L41
 621:main.c        **** 
 807               	.LM108:
 808 01f4 83E5      		ldi r24,lo8(83)
 809 01f6 00C0      		rjmp .L61
 810               	.L41:
 651:main.c        **** 		{
 812               	.LM109:
 813 01f8 8437      		cpi r24,lo8(116)
 814 01fa 01F4      		brne .L42
 653:main.c        **** 		sendchar(0);
 816               	.LM110:
 817 01fc 87E7      		ldi r24,lo8(119)
 818 01fe 00D0      		rcall sendchar
 819               	.L63:
 654:main.c        **** 		// clear and set LED ignored
 821               	.LM111:
 822 0200 80E0      		ldi r24,0
 823 0202 00C0      		rjmp .L61
 824               	.L42:
 657:main.c        **** 		{
 826               	.LM112:
 827 0204 98E8      		ldi r25,lo8(-120)
 828 0206 980F      		add r25,r24
 829 0208 9230      		cpi r25,lo8(2)
 830 020a 00F4      		brsh .L43
 659:main.c        **** 		sendchar('\r');
 832               	.LM113:
 833 020c 00D0      		rcall recvchar
 834 020e 00C0      		rjmp .L62
 835               	.L43:
 664:main.c        **** 		{
 837               	.LM114:
 838 0210 8435      		cpi r24,lo8(84)
 839 0212 01F4      		brne .L44
 666:main.c        **** 		sendchar('\r');
 841               	.LM115:
 842 0214 00D0      		rcall recvchar
 843 0216 182F      		mov r17,r24
 844               	.L62:
 667:main.c        **** 		// Return software identifier
 846               	.LM116:
 847 0218 8DE0      		ldi r24,lo8(13)
 848 021a 00C0      		rjmp .L61
 849               	.L44:
 670:main.c        **** 		{
 851               	.LM117:
 852 021c 8335      		cpi r24,lo8(83)
 853 021e 01F4      		brne .L45
 854               	.LBB57:
 855               	.LBB58:
 336:main.c        **** 	sendchar('V');
 857               	.LM118:
 858 0220 81E4      		ldi r24,lo8(65)
 859 0222 00D0      		rcall sendchar
 337:main.c        **** 	sendchar('R');
 861               	.LM119:
 862 0224 86E5      		ldi r24,lo8(86)
 863 0226 00D0      		rcall sendchar
 338:main.c        **** 	sendchar('B');
 865               	.LM120:
 866 0228 82E5      		ldi r24,lo8(82)
 867 022a 00D0      		rcall sendchar
 339:main.c        **** 	sendchar('O');
 869               	.LM121:
 870 022c 82E4      		ldi r24,lo8(66)
 871 022e 00D0      		rcall sendchar
 340:main.c        **** 	sendchar('O');
 873               	.LM122:
 874 0230 8FE4      		ldi r24,lo8(79)
 875 0232 00D0      		rcall sendchar
 341:main.c        **** 	sendchar('T');
 877               	.LM123:
 878 0234 8FE4      		ldi r24,lo8(79)
 879 0236 00D0      		rcall sendchar
 342:main.c        **** }
 881               	.LM124:
 882 0238 84E5      		ldi r24,lo8(84)
 883 023a 00C0      		rjmp .L61
 884               	.L45:
 885               	.LBE58:
 886               	.LBE57:
 676:main.c        **** 		sendchar(VERSION_HIGH);
 888               	.LM125:
 889 023c 8635      		cpi r24,lo8(86)
 890 023e 01F4      		brne .L46
 677:main.c        **** 		sendchar(VERSION_LOW);
 892               	.LM126:
 893 0240 80E3      		ldi r24,lo8(48)
 894 0242 00D0      		rcall sendchar
 678:main.c        **** 
 896               	.LM127:
 897 0244 88E3      		ldi r24,lo8(56)
 898 0246 00C0      		rjmp .L61
 899               	.L46:
 684:main.c        **** 		{
 901               	.LM128:
 902 0248 8337      		cpi r24,lo8(115)
 903 024a 01F4      		brne .L47
 686:main.c        **** 		sendchar(SIG_BYTE2);
 905               	.LM129:
 906 024c 87E0      		ldi r24,lo8(7)
 907 024e 00D0      		rcall sendchar
 687:main.c        **** 		sendchar(SIG_BYTE1);
 909               	.LM130:
 910 0250 83E9      		ldi r24,lo8(-109)
 911 0252 00D0      		rcall sendchar
 688:main.c        **** 
 913               	.LM131:
 914 0254 8EE1      		ldi r24,lo8(30)
 915 0256 00C0      		rjmp .L61
 916               	.L47:
 692:main.c        **** 		{
 918               	.LM132:
 919 0258 8B31      		cpi r24,lo8(27)
 920 025a 01F4      		brne .+2
 921 025c 00C0      		rjmp .L19
 694:main.c        **** 		}
 923               	.LM133:
 924 025e 8FE3      		ldi r24,lo8(63)
 925               	.L61:
 926 0260 00D0      		rcall sendchar
 927 0262 00C0      		rjmp .L19
 945               	.Lscope5:
 946               		.comm	time_out,1,1
 947               		.comm	gBuffer,64,1
 950               		.text
 952               	.Letext0:
 953               		.ident	"GCC: (AVR_8_bit_GNU_Toolchain_3.5.1_1671) 4.9.2"
 954               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
  E:\Temp\ccl8mTtv.s:2      *ABS*:0000003e __SP_H__
  E:\Temp\ccl8mTtv.s:3      *ABS*:0000003d __SP_L__
  E:\Temp\ccl8mTtv.s:4      *ABS*:0000003f __SREG__
  E:\Temp\ccl8mTtv.s:5      *ABS*:00000000 __tmp_reg__
  E:\Temp\ccl8mTtv.s:6      *ABS*:00000001 __zero_reg__
  E:\Temp\ccl8mTtv.s:115    .text:00000000 TimeOut
                            *COM*:00000001 time_out
  E:\Temp\ccl8mTtv.s:162    .text:00000028 recvchar
  E:\Temp\ccl8mTtv.s:194    .text:00000038 sendchar
  E:\Temp\ccl8mTtv.s:237    .text:0000005c __vector_default
  E:\Temp\ccl8mTtv.s:252    .text.startup:00000000 main
                            *COM*:00000040 gBuffer

UNDEFINED SYMBOLS
__do_clear_bss
