   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 116               	sendchar:
   1:main.c        **** /*****************************************************************************
   2:main.c        **** *
   3:main.c        **** * AVRPROG compatible boot-loader
   4:main.c        **** * Version  : 0.85 (Dec. 2008)
   5:main.c        **** * Compiler : avr-gcc 4.1.2 / avr-libc 1.4.6
   6:main.c        **** * size     : depends on features and startup ( minmal features < 512 words)
   7:main.c        **** * by       : Martin Thomas, Kaiserslautern, Germany
   8:main.c        **** *            eversmith@heizung-thomas.de
   9:main.c        **** *            Additional code and improvements contributed by:
  10:main.c        **** *           - Uwe Bonnes
  11:main.c        **** *           - Bjoern Riemer
  12:main.c        **** *           - Olaf Rempel
  13:main.c        **** *
  14:main.c        **** * License  : Copyright (c) 2006-2008 M. Thomas, U. Bonnes, O. Rempel
  15:main.c        **** *            Free to use. You have to mention the copyright
  16:main.c        **** *            owners in source-code and documentation of derived
  17:main.c        **** *            work. No warranty! (Yes, you can insert the BSD
  18:main.c        **** *            license here)
  19:main.c        **** *
  20:main.c        **** * Tested with ATmega8, ATmega16, ATmega162, ATmega32, ATmega324P,
  21:main.c        **** *             ATmega644, ATmega644P, ATmega128, AT90CAN128
  22:main.c        **** *
  23:main.c        **** * - Initial versions have been based on the Butterfly bootloader-code
  24:main.c        **** *   by Atmel Corporation (Authors: BBrandal, PKastnes, ARodland, LHM)
  25:main.c        **** *
  26:main.c        **** ****************************************************************************
  27:main.c        **** *
  28:main.c        **** *  See the makefile and readme.txt for information on how to adapt 
  29:main.c        **** *  the linker-settings to the selected Boot Size (BOOTSIZE=xxxx) and 
  30:main.c        **** *  the MCU-type. Other configurations futher down in this file.
  31:main.c        **** *
  32:main.c        **** *  With BOOT_SIMPLE, minimal features and discarded int-vectors
  33:main.c        **** *  this bootloader has should fit into a a 512 word (1024, 0x400 bytes) 
  34:main.c        **** *  bootloader-section. 
  35:main.c        **** *
  36:main.c        **** ****************************************************************************/
  37:main.c        **** 
  38:main.c        **** /* Частота контроллера (кварца) */
  39:main.c        **** #ifndef F_CPU
  40:main.c        **** // #define F_CPU 7372800
  41:main.c        **** //#define F_CPU (7372800/2)
  42:main.c        **** #define F_CPU 8000000
  43:main.c        **** #endif
  44:main.c        **** 
  45:main.c        **** /* UART Скорость UART оптимально 19200 */
  46:main.c        **** //#define BAUDRATE 9600
  47:main.c        **** #define BAUDRATE 19200
  48:main.c        **** //#define BAUDRATE 115200
  49:main.c        **** 
  50:main.c        **** /* Режим двойной скорости UART (бит U2C)*/
  51:main.c        **** //#define UART_DOUBLESPEED
  52:main.c        **** 
  53:main.c        **** /* Используется второй UART на mega128 / can128 / mega162 / mega324p / mega644p */
  54:main.c        **** //#define UART_USE_SECOND
  55:main.c        **** 
  56:main.c        **** /* Тип устройства:
  57:main.c        ****    Для AVRProg выбирать BOOT 
  58:main.c        ****    Это корректное значение для bootloader.
  59:main.c        ****    avrdude может определить только part-code для ISP */
  60:main.c        **** #define DEVTYPE     DEVTYPE_BOOT
  61:main.c        **** // #define DEVTYPE     DEVTYPE_ISP
  62:main.c        **** 
  63:main.c        **** /*
  64:main.c        ****  * Выбор порта для кнопки входа в загрузчик
  65:main.c        ****  * Чтобы войти в загрузчик надо чтобы при запуске эта кнопка замыкала пин на землю
  66:main.c        ****  */
  67:main.c        **** #define BLPORT		PORTD
  68:main.c        **** #define BLDDR		DDRD
  69:main.c        **** #define BLPIN		PIND
  70:main.c        **** #define BLPNUM		PIND5
  71:main.c        **** 
  72:main.c        **** #define BL_2_PORT		PORTB
  73:main.c        **** #define BL_2_DDR		DDRB
  74:main.c        **** #define BL_2_PIN		PINB
  75:main.c        **** #define BL_2_PNUM		PINB7
  76:main.c        **** 
  77:main.c        **** #define RELE_PORT		PORTB
  78:main.c        **** #define RELE_DDR		DDRB
  79:main.c        **** #define RELE_PIN		PINB
  80:main.c        **** #define RELE_PNUM		PINB1
  81:main.c        **** 
  82:main.c        **** 
  83:main.c        **** /*
  84:main.c        ****  * Выбор порта для индикатора работы загрузчика
  85:main.c        ****  * Светодиод горит - мы в загрузчике
  86:main.c        ****  */
  87:main.c        **** 
  88:main.c        **** #define ENABLE_BOOT_LED
  89:main.c        **** #define BIPORT		PORTD
  90:main.c        **** #define BIDDR		DDRD
  91:main.c        **** #define BIPIN		PIND
  92:main.c        **** #define BIPNUM		PIND5
  93:main.c        **** 
  94:main.c        **** 
  95:main.c        **** /*
  96:main.c        ****  * Выключить Собачий таймер на время загрузчика
  97:main.c        ****  */
  98:main.c        **** #define DISABLE_WDT_AT_STARTUP
  99:main.c        **** 
 100:main.c        **** /*
 101:main.c        ****  * Watchdog-reset is issued at exit 
 102:main.c        ****  * define the timeout-value here (see avr-libc manual)
 103:main.c        ****  */
 104:main.c        **** #define EXIT_WDT_TIME   WDTO_250MS
 105:main.c        **** 
 106:main.c        **** /*
 107:main.c        ****  * Выбор режима загрузчика
 108:main.c        ****  * SIMPLE-Mode - Загрузчик стартует когда нажата его кнопка
 109:main.c        ****  *   переход к основной программе осуществляется после сброса 
 110:main.c        ****  *   (кнопка должна быть отжата) либо по команде от программатора
 111:main.c        ****  *   При этом режиме вывод на кнопку конфигурируется как вход-с подтягом,
 112:main.c        ****  *   но при выходе из загрузчика все выставляется по умолчанию
 113:main.c        ****  * POWERSAVE-Mode - Startup is separated in two loops
 114:main.c        ****  *   which makes power-saving a little easier if no firmware
 115:main.c        ****  *   is on the chip. Needs more memory
 116:main.c        ****  * BOOTICE-Mode - для зашивки  JTAGICE файла upgrade.ebn в Мегу16.
 117:main.c        ****  *   что превращает ее в JTAG отладчик. Разумеется нужно добавить весь необходимый
 118:main.c        ****  *   обвяз на кристалл для этого. И частота должна быть везде прописана как 7372800
 119:main.c        ****  *   в F_CPU Для совместимости с родной прошивкой JTAG ICE
 120:main.c        ****  * WAIT-mode Bootloader ожидает команды на вход, если ее не было в течении промежутка времени
 121:main.c        ****  *   (который настраивается) то проихсодит переход к основной программе.
 122:main.c        ****  */
 123:main.c        **** #define START_SIMPLE
 124:main.c        **** //#define START_WAIT
 125:main.c        **** //#define START_POWERSAVE
 126:main.c        **** //#define START_BOOTICE
 127:main.c        **** 
 128:main.c        **** /* Команда для входа в загрузчик в START_WAIT */
 129:main.c        **** #define START_WAIT_UARTCHAR 'S'
 130:main.c        **** 
 131:main.c        **** /* Выдержка для START_WAIT mode ( t = WAIT_TIME * 10ms ) */
 132:main.c        **** #define WAIT_VALUE 400 /* сейчас: 300*10ms = 3000ms = 3sec */
 133:main.c        **** 
 134:main.c        **** /*
 135:main.c        ****  * enable/disable readout of fuse and lock-bits
 136:main.c        ****  * (AVRPROG has to detect the AVR correctly by device-code
 137:main.c        ****  * to show the correct information).
 138:main.c        ****  */
 139:main.c        **** //#define ENABLEREADFUSELOCK
 140:main.c        **** 
 141:main.c        **** /* enable/disable write of lock-bits
 142:main.c        ****  * WARNING: lock-bits can not be reseted by bootloader (as far as I know)
 143:main.c        ****  * Only protection no unprotection, "chip erase" from bootloader only
 144:main.c        ****  * clears the flash but does no real "chip erase" (this is not possible
 145:main.c        ****  * with a bootloader as far as I know)
 146:main.c        ****  * Keep this undefined!
 147:main.c        ****  */
 148:main.c        **** //#define WRITELOCKBITS
 149:main.c        **** 
 150:main.c        **** /*
 151:main.c        ****  * define the following if the bootloader should not output
 152:main.c        ****  * itself at flash read (will fake an empty boot-section)
 153:main.c        ****  */
 154:main.c        **** //#define READ_PROTECT_BOOTLOADER 
 155:main.c        **** 
 156:main.c        **** #define VERSION_HIGH '0'
 157:main.c        **** #define VERSION_LOW  '8'
 158:main.c        **** 
 159:main.c        **** #define GET_LOCK_BITS           0x0001
 160:main.c        **** #define GET_LOW_FUSE_BITS       0x0000
 161:main.c        **** #define GET_HIGH_FUSE_BITS      0x0003
 162:main.c        **** #define GET_EXTENDED_FUSE_BITS  0x0002
 163:main.c        **** 
 164:main.c        **** /* Расчет делителя частоты для USART*/
 165:main.c        **** #ifdef UART_DOUBLESPEED
 166:main.c        **** 
 167:main.c        **** 	#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 4UL)) / ((uint32_
 168:main.c        **** 
 169:main.c        **** #else
 170:main.c        **** 
 171:main.c        **** 	#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 8UL)) / ((uint32_
 172:main.c        **** 
 173:main.c        **** #endif
 174:main.c        **** 
 175:main.c        **** 
 176:main.c        **** #include <stdint.h>
 177:main.c        **** #include <avr/io.h>
 178:main.c        **** #include <avr/wdt.h>
 179:main.c        **** #include <avr/boot.h>
 180:main.c        **** #include <avr/pgmspace.h>
 181:main.c        **** #include <avr/eeprom.h>
 182:main.c        **** #include <avr/interrupt.h>
 183:main.c        **** #include <util/delay.h>
 184:main.c        **** 
 185:main.c        **** #include "chipdef.h"
 186:main.c        **** 
 187:main.c        **** uint8_t gBuffer[SPM_PAGESIZE];
 188:main.c        **** 
 189:main.c        **** #if defined(BOOTLOADERHASNOVECTORS)
 190:main.c        **** 	#warning "This Bootloader does not link interrupt vectors - see makefile"
 191:main.c        **** 	/* make the linker happy - it wants to see __vector_default */
 192:main.c        **** 	// void __vector_default(void) { ; }
 193:main.c        **** 	void __vector_default(void) { ; }
 194:main.c        **** #endif
 195:main.c        **** 
 196:main.c        **** static void sendchar(uint8_t data)
 197:main.c        **** {
 118               	.LM0:
 119               	.LFBB1:
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 0 */
 123               	.L__stack_usage = 0
 124               	.L2:
 198:main.c        **** 	while (!(UART_STATUS & (1<<UART_TXREADY)));
 126               	.LM1:
 127 0000 5D9B      		sbis 0xb,5
 128 0002 00C0      		rjmp .L2
 199:main.c        **** 	UART_DATA = data;
 130               	.LM2:
 131 0004 8CB9      		out 0xc,r24
 132 0006 0895      		ret
 134               	.Lscope1:
 137               	recvchar:
 200:main.c        **** }
 201:main.c        **** 
 202:main.c        **** static uint8_t recvchar(void)
 203:main.c        **** {
 139               	.LM3:
 140               	.LFBB2:
 141               	/* prologue: function */
 142               	/* frame size = 0 */
 143               	/* stack size = 0 */
 144               	.L__stack_usage = 0
 145               	.L7:
 204:main.c        **** 	while (!(UART_STATUS & (1<<UART_RXREADY)));
 147               	.LM4:
 148 0008 5F9B      		sbis 0xb,7
 149 000a 00C0      		rjmp .L7
 205:main.c        **** 	return UART_DATA;
 151               	.LM5:
 152 000c 8CB1      		in r24,0xc
 206:main.c        **** }
 154               	.LM6:
 155 000e 0895      		ret
 157               	.Lscope2:
 159               	.global	__vector_default
 161               	__vector_default:
 193:main.c        **** #endif
 163               	.LM7:
 164               	.LFBB3:
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
 169 0010 0895      		ret
 171               	.Lscope3:
 172               		.section	.text.startup,"ax",@progbits
 174               	.global	main
 176               	main:
 207:main.c        **** 
 208:main.c        **** static inline void eraseFlash(void)
 209:main.c        **** {
 210:main.c        **** 	// erase only main section (bootloader protection)
 211:main.c        **** 	uint32_t addr = 0;
 212:main.c        **** 	while (APP_END > addr) 
 213:main.c        **** 		{
 214:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 215:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 216:main.c        **** 		addr += SPM_PAGESIZE;
 217:main.c        **** 		}
 218:main.c        **** 	boot_rww_enable();
 219:main.c        **** }
 220:main.c        **** 
 221:main.c        **** static inline void recvBuffer(pagebuf_t size)
 222:main.c        **** {
 223:main.c        **** 	pagebuf_t cnt;
 224:main.c        **** 	uint8_t *tmp = gBuffer;
 225:main.c        **** 
 226:main.c        **** 	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) 
 227:main.c        **** 		{
 228:main.c        **** 		*tmp++ = (cnt < size) ? recvchar() : 0xFF;
 229:main.c        **** 		}
 230:main.c        **** }
 231:main.c        **** 
 232:main.c        **** static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
 233:main.c        **** {
 234:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 235:main.c        **** 	uint32_t baddr = pagestart;
 236:main.c        **** 	uint16_t data;
 237:main.c        **** 	uint8_t *tmp = gBuffer;
 238:main.c        **** 
 239:main.c        **** 	do 
 240:main.c        **** 		{
 241:main.c        **** 		data = *tmp++;
 242:main.c        **** 		data |= *tmp++ << 8;
 243:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 244:main.c        **** 
 245:main.c        **** 		baddr += 2;			// Select next word in memory
 246:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 247:main.c        **** 		} 
 248:main.c        **** 	while (size);				// Loop until all bytes written
 249:main.c        **** 
 250:main.c        **** 	boot_page_write(pagestart);
 251:main.c        **** 	boot_spm_busy_wait();
 252:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 253:main.c        **** 
 254:main.c        **** 	return baddr>>1;
 255:main.c        **** }
 256:main.c        **** 
 257:main.c        **** static inline uint16_t writeEEpromPage(uint16_t address, pagebuf_t size)
 258:main.c        **** {
 259:main.c        **** 	uint8_t *tmp = gBuffer;
 260:main.c        **** 
 261:main.c        **** 	do 
 262:main.c        **** 		{
 263:main.c        **** 		eeprom_write_byte( (uint8_t*)address, *tmp++ );
 264:main.c        **** 		address++;			// Select next byte
 265:main.c        **** 		size--;				// Decreas number of bytes to write
 266:main.c        **** 		}
 267:main.c        **** 	while (size);				// Loop until all bytes written
 268:main.c        **** 
 269:main.c        **** 	// eeprom_busy_wait();
 270:main.c        **** 
 271:main.c        **** 	return address;
 272:main.c        **** }
 273:main.c        **** 
 274:main.c        **** static inline uint16_t readFlashPage(uint16_t waddr, pagebuf_t size)
 275:main.c        **** {
 276:main.c        **** 	uint32_t baddr = (uint32_t)waddr<<1;
 277:main.c        **** 	uint16_t data;
 278:main.c        **** 
 279:main.c        **** 	do 
 280:main.c        **** 	{
 281:main.c        **** 
 282:main.c        **** #ifndef READ_PROTECT_BOOTLOADER
 283:main.c        **** #warning "Bootloader not read-protected"
 284:main.c        **** 
 285:main.c        **** 	#if defined(RAMPZ)
 286:main.c        **** 		data = pgm_read_word_far(baddr);
 287:main.c        **** 	#else
 288:main.c        **** 		data = pgm_read_word_near(baddr);
 289:main.c        **** 	#endif
 290:main.c        **** 
 291:main.c        **** #else
 292:main.c        **** 		// don't read bootloader
 293:main.c        **** 		if ( baddr < APP_END ) 
 294:main.c        **** 		{
 295:main.c        **** 		#if defined(RAMPZ)
 296:main.c        **** 			data = pgm_read_word_far(baddr);
 297:main.c        **** 		#else
 298:main.c        **** 			data = pgm_read_word_near(baddr);
 299:main.c        **** 		#endif
 300:main.c        **** 		}
 301:main.c        **** 		else 
 302:main.c        **** 		{
 303:main.c        **** 		data = 0xFFFF; // fake empty
 304:main.c        **** 		}
 305:main.c        **** #endif
 306:main.c        **** 		sendchar(data);			// send LSB
 307:main.c        **** 		sendchar((data >> 8));		// send MSB
 308:main.c        **** 		baddr += 2;			// Select next word in memory
 309:main.c        **** 		size -= 2;			// Subtract two bytes from number of bytes to read
 310:main.c        **** 	} 
 311:main.c        **** 	while (size);				// Repeat until block has been read
 312:main.c        **** 	return baddr>>1;
 313:main.c        **** }
 314:main.c        **** 
 315:main.c        **** static inline uint16_t readEEpromPage(uint16_t address, pagebuf_t size)
 316:main.c        **** {
 317:main.c        **** 	do 
 318:main.c        **** 	{
 319:main.c        **** 	sendchar( eeprom_read_byte( (uint8_t*)address ) );
 320:main.c        **** 	address++;
 321:main.c        **** 	size--;				// Decrease number of bytes to read
 322:main.c        **** 	} 
 323:main.c        **** 	while (size);				// Repeat until block has been read
 324:main.c        **** 
 325:main.c        **** 	return address;
 326:main.c        **** }
 327:main.c        **** 
 328:main.c        **** #if defined(ENABLEREADFUSELOCK)
 329:main.c        **** static uint8_t read_fuse_lock(uint16_t addr)
 330:main.c        **** {
 331:main.c        **** 	uint8_t mode = (1<<BLBSET) | (1<<SPMEN);
 332:main.c        **** 	uint8_t retval;
 333:main.c        **** 
 334:main.c        **** 	asm volatile
 335:main.c        **** 	(
 336:main.c        **** 		"movw r30, %3\n\t"		/* Z to addr */ \
 337:main.c        **** 		"sts %0, %2\n\t"		/* set mode in SPM_REG */ \
 338:main.c        **** 		"lpm\n\t"			/* load fuse/lock value into r0 */ \
 339:main.c        **** 		"mov %1,r0\n\t"			/* save return value */ \
 340:main.c        **** 		: "=m" (SPM_REG),
 341:main.c        **** 		  "=r" (retval)
 342:main.c        **** 		: "r" (mode),
 343:main.c        **** 		  "r" (addr)
 344:main.c        **** 		: "r30", "r31", "r0"
 345:main.c        **** 	);
 346:main.c        **** 	return retval;
 347:main.c        **** }
 348:main.c        **** #endif
 349:main.c        **** 
 350:main.c        **** static void send_boot(void)
 351:main.c        **** {
 352:main.c        **** 	sendchar('A');
 353:main.c        **** 	sendchar('V');
 354:main.c        **** 	sendchar('R');
 355:main.c        **** 	sendchar('B');
 356:main.c        **** 	sendchar('O');
 357:main.c        **** 	sendchar('O');
 358:main.c        **** 	sendchar('T');
 359:main.c        **** }
 360:main.c        **** 
 361:main.c        **** static void (*jump_to_app)(void) = 0x0000;
 362:main.c        **** 
 363:main.c        **** int main(void)
 364:main.c        **** {
 178               	.LM8:
 179               	.LFBB4:
 181               	.LM9:
 182 0000 CF93      		push r28
 183 0002 DF93      		push r29
 184 0004 1F92      		push __zero_reg__
 185 0006 CDB7      		in r28,__SP_L__
 186 0008 DEB7      		in r29,__SP_H__
 187               	/* prologue: function */
 188               	/* frame size = 1 */
 189               	/* stack size = 3 */
 190               	.L__stack_usage = 3
 365:main.c        **** 	uint16_t address = 0;
 366:main.c        **** 	uint8_t device = 0, val;
 367:main.c        **** 
 368:main.c        **** 
 369:main.c        **** 
 370:main.c        **** #ifdef ENABLE_BOOT_LED	// LED ON
 371:main.c        **** 	BIPORT |= (1<<BIPNUM);	
 192               	.LM10:
 193 000a 959A      		sbi 0x12,5
 372:main.c        **** 	BIDDR  |= (1<<BIPNUM);
 195               	.LM11:
 196 000c 8D9A      		sbi 0x11,5
 373:main.c        **** #endif
 374:main.c        **** 
 375:main.c        **** 
 376:main.c        **** #ifdef DISABLE_WDT_AT_STARTUP
 377:main.c        **** 	#ifdef WDT_OFF_SPECIAL
 378:main.c        **** 		#warning "using target specific watchdog_off"
 379:main.c        **** 		bootloader_wdt_off();
 380:main.c        **** 	#else
 381:main.c        **** 		cli();
 198               	.LM12:
 199               	/* #APP */
 200               	 ;  381 "main.c" 1
 201 000e F894      		cli
 202               	 ;  0 "" 2
 382:main.c        **** 		wdt_reset();
 204               	.LM13:
 205               	 ;  382 "main.c" 1
 206 0010 A895      		wdr
 207               	 ;  0 "" 2
 208               	/* #NOAPP */
 209               	.LBB34:
 210               	.LBB35:
 212               	.Ltext1:
   1:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    All rights reserved.
   4:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
   5:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
   8:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    * Redistributions of source code must retain the above copyright
   9:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  11:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****      the documentation and/or other materials provided with the
  14:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****      distribution.
  15:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  16:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****      contributors may be used to endorse or promote products derived
  18:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****      from this software without specific prior written permission.
  19:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  20:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  32:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /* $Id$ */
  33:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  34:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /*
  35:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****  */
  37:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  38:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #ifndef _AVR_WDT_H_
  39:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define _AVR_WDT_H_
  40:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  41:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #include <avr/io.h>
  42:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #include <stdint.h>
  43:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  44:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /** \file */
  45:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  48:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     This header file declares the interface to some inline macros
  49:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     to prevent the watchdog timer configuration from being
  51:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     accidentally altered by a crashing application, a special timed
  52:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     sequence is required in order to change it.  The macros within
  53:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     this header file handle the required sequence automatically
  54:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     the manipulation.
  56:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  57:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     \note Depending on the fuse configuration of the particular
  58:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     device, further restrictions might apply, in particular it might
  59:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     be disallowed to turn off the watchdog timer.
  60:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  61:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     timer remains active even after a system reset (except a power-on
  64:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     the following:
  68:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  69:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     \code
  70:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     #include <stdint.h>
  71:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     #include <avr/wdt.h>
  72:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  73:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  75:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     void get_mcusr(void) \
  76:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       __attribute__((naked)) \
  77:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       __attribute__((section(".init3")));
  78:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     void get_mcusr(void)
  79:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     {
  80:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       mcusr_mirror = MCUSR;
  81:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       MCUSR = 0;
  82:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       wdt_disable();
  83:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     }
  84:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     \endcode
  85:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  86:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     clearing the watchdog reset flag before disabling the
  89:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     watchdog is required, according to the datasheet.
  90:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** */
  91:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  92:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /**
  93:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    \ingroup avr_watchdog
  94:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    a call to this instruction is required before the timer expires,
  96:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** */
  98:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
  99:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 101:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 102:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #if defined(WDP3)
 103:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 104:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #else
 105:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** # define _WD_PS3_MASK       0x00
 106:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #endif
 107:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 108:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #if defined(WDTCSR)
 109:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 110:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #elif defined(WDTCR)
 111:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 112:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #else
 113:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #  define _WD_CONTROL_REG     WDT
 114:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #endif
 115:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 116:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #if defined(WDTOE)
 117:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 118:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #else
 119:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define _WD_CHANGE_BIT      WDCE
 120:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #endif
 121:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 122:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 123:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /**
 124:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    \ingroup avr_watchdog
 125:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 126:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 127:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 128:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 129:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    through \c WDP3 bits).
 130:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 131:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 132:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** */
 133:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 134:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 135:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #if defined(__AVR_XMEGA__)
 136:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 137:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 138:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 139:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_enable(timeout) \
 140:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** do { \
 141:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** uint8_t temp; \
 142:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __asm__ __volatile__ ( \
 143:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"wdr"									"\n\t" \
 144:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 145:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 146:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 147:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 148:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 149:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 150:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"rjmp 1b"								"\n\t" \
 151:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	: [tmp]					"=r" (temp) \
 152:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 153:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 154:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 155:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 156:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 157:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 158:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ); \
 159:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** } while(0)
 160:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 161:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_disable() \
 162:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** do { \
 163:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** uint8_t temp; \
 164:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __asm__ __volatile__ (  \
 165:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"wdr"								"\n\t" \
 166:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 167:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 168:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 169:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 170:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [tmp]            "=r" (temp) \
 171:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 172:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 173:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 174:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 175:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ); \
 176:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** } while(0)
 177:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 178:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 179:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 180:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** /*
 181:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    wdt_enable(timeout) for xmega devices
 182:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 183:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    registers to the CCP register
 184:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ** At the same time,
 185:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 186:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 187:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    3) set timeout (timeout)
 188:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 189:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 190:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****    sync is finished).
 191:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** */
 192:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_enable(timeout) \
 193:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** do { \
 194:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** uint8_t temp; \
 195:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __asm__ __volatile__ (         \
 196:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 197:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 198:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 199:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 200:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 201:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 202:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "rjmp 1b"                               "\n\t" \
 203:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 204:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [tmp]                "=r" (temp) \
 205:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 206:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 207:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 208:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 209:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 210:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 211:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 212:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : "r0" \
 213:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ); \
 214:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** } while(0)
 215:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 216:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_disable() \
 217:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __asm__ __volatile__ (  \
 218:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 219:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 220:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 221:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 222:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 223:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : \
 224:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 225:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 226:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 227:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 228:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 229:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : "r0" \
 230:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** );
 231:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 232:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 233:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 234:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #elif defined(__AVR_TINY__)
 235:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 236:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_enable(value) \
 237:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __asm__ __volatile__ ( \
 238:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 239:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "cli" "\n\t"  \
 240:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "wdr" "\n\t"  \
 241:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 242:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 243:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 244:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : /* no outputs */  \
 245:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 246:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 247:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 248:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 249:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 250:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : "r16" \
 251:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** )
 252:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 253:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #define wdt_disable() \
 254:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** do { \
 255:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** uint8_t temp_wd; \
 256:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __asm__ __volatile__ ( \
 257:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 258:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "cli" "\n\t"  \
 259:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "wdr" "\n\t"  \
 260:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 261:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 262:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 263:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 264:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 265:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : /*no output */ \
 266:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 267:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 268:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 269:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 270:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 271:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****     : "r16" \
 272:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** ); \
 273:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** }while(0)
 274:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 275:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #elif defined(CCP)
 276:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 277:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** static __inline__
 278:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __attribute__ ((__always_inline__))
 279:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** void wdt_enable (const uint8_t value)
 280:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** {
 281:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 282:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 283:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 284:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 285:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"cli" "\n\t"
 286:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"wdr" "\n\t"
 287:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 288:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 289:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 290:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: /* no outputs */
 291:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 292:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 293:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 294:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 295:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 296:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: "r0"
 297:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			);
 298:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 299:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 300:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 301:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 302:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 303:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"cli" "\n\t"
 304:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"wdr" "\n\t"
 305:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 306:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 307:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 308:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: /* no outputs */
 309:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 310:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 311:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 312:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 313:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 314:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: "r0"
 315:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			);
 316:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 317:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 318:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 319:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 320:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 321:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"cli" "\n\t"
 322:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"wdr" "\n\t"
 323:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 324:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 325:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 326:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: /* no outputs */
 327:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 328:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 329:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 330:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 331:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 332:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: "r0"
 333:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			);
 334:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 335:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else
 336:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****  	{
 337:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 338:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 339:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"cli" "\n\t"
 340:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"wdr" "\n\t"
 341:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 342:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 343:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 344:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: /* no outputs */
 345:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 346:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 347:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 348:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 349:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 350:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			: "r0"
 351:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 			);
 352:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 353:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** }
 354:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 355:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** static __inline__
 356:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __attribute__ ((__always_inline__))
 357:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** void wdt_disable (void)
 358:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** {
 359:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 360:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 361:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         uint8_t temp_wd;
 362:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         __asm__ __volatile__ (
 363:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 364:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cli" "\n\t"
 365:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"wdr" "\n\t"
 366:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 367:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 368:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 369:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 370:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 371:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: /*no output */
 372:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 373:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 374:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 375:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 376:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 377:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "r0"
 378:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				);
 379:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 380:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 381:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 382:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         uint8_t temp_wd;
 383:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         __asm__ __volatile__ (
 384:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 385:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cli" "\n\t"
 386:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"wdr" "\n\t"
 387:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 388:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 389:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 390:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 391:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 392:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: /*no output */
 393:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 394:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 395:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 396:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 397:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 398:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "r0"
 399:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				);
 400:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 401:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 402:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 403:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         uint8_t temp_wd;
 404:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         __asm__ __volatile__ (
 405:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 406:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cli" "\n\t"
 407:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"wdr" "\n\t"
 408:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 409:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 410:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 411:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 412:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 413:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: /*no output */
 414:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 415:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 416:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 417:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 418:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 419:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "r0"
 420:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				);
 421:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 422:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else
 423:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 424:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         uint8_t temp_wd;
 425:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         __asm__ __volatile__ (
 426:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 427:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cli" "\n\t"
 428:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"wdr" "\n\t"
 429:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 430:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 431:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 432:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 433:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 434:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: /*no output */
 435:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 436:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 437:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 438:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 439:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 440:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "r0"
 441:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				);
 442:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 443:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** }
 444:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 445:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** #else
 446:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 447:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** static __inline__
 448:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __attribute__ ((__always_inline__))
 449:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** void wdt_enable (const uint8_t value)
 450:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** {
 451:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 452:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 453:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 454:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 455:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cli" "\n\t"
 456:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"wdr" "\n\t"
 457:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out %0, %1" "\n\t"
 458:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 459:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out %0, %2" "\n \t"
 460:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: /* no outputs */
 461:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 462:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 463:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 464:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 465:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "r0"
 466:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		);
 467:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 468:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	else
 469:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 470:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 471:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 472:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"cli" "\n\t"
 473:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"wdr" "\n\t"
 474:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"sts %0, %1" "\n\t"
 475:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 476:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"sts %0, %2" "\n \t"
 477:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: /* no outputs */
 478:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 479:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 480:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 481:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 482:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				: "r0"
 483:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		);
 484:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	}
 485:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** }
 486:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 
 487:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** static __inline__
 488:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** __attribute__ ((__always_inline__))
 489:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** void wdt_disable (void)
 490:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** {
 491:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 492:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 	{
 493:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h ****         uint8_t register temp_reg;
 494:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 		__asm__ __volatile__ (
 214               	.LM14:
 215               	/* #APP */
 216               	 ;  494 "e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\
 217 0012 0FB6      		in __tmp_reg__,__SREG__
 218 0014 F894      		cli
 219 0016 A895      		wdr
 220 0018 81B5      		in  r24,33
 221 001a 8861      		ori r24,24
 222 001c 81BD      		out 33,r24
 223 001e 11BC      		out 33,__zero_reg__
 224 0020 0FBE      		out __SREG__,__tmp_reg__
 225               		
 226               	 ;  0 "" 2
 227               	/* #NOAPP */
 228               	.LBE35:
 229               	.LBE34:
 231               	.Ltext2:
 383:main.c        **** 		wdt_disable();
 384:main.c        **** 	#endif
 385:main.c        **** #endif
 386:main.c        **** 	
 387:main.c        **** #ifdef START_POWERSAVE
 388:main.c        **** 	uint8_t OK = 1;
 389:main.c        **** #endif
 390:main.c        **** 
 391:main.c        **** 	RELE_DDR  |=  (1<<RELE_PNUM);		// set as Output
 233               	.LM15:
 234 0022 B99A      		sbi 0x17,1
 392:main.c        **** 	RELE_PORT &= ~(1<<RELE_PNUM);		// Rele turn off
 236               	.LM16:
 237 0024 C198      		cbi 0x18,1
 393:main.c        **** 
 394:main.c        **** 	BLDDR  &= ~(1<<BLPNUM);		// set as Input
 239               	.LM17:
 240 0026 8D98      		cbi 0x11,5
 395:main.c        **** 	BLPORT |= (1<<BLPNUM);		// Enable pullup
 242               	.LM18:
 243 0028 959A      		sbi 0x12,5
 396:main.c        **** 	
 397:main.c        **** 	BL_2_DDR  &= ~(1<<BL_2_PNUM);		// set as Input
 245               	.LM19:
 246 002a BF98      		cbi 0x17,7
 398:main.c        **** 	BL_2_PORT |= (1<<BL_2_PNUM);		// Enable pullup
 248               	.LM20:
 249 002c C79A      		sbi 0x18,7
 399:main.c        **** 
 400:main.c        **** 	// Set baud rate
 401:main.c        **** 	UART_BAUD_HIGH = (UART_CALC_BAUDRATE(BAUDRATE)>>8) & 0xFF;
 251               	.LM21:
 252 002e 10BC      		out 0x20,__zero_reg__
 402:main.c        **** 	UART_BAUD_LOW = (UART_CALC_BAUDRATE(BAUDRATE) & 0xFF);
 254               	.LM22:
 255 0030 89E1      		ldi r24,lo8(25)
 256 0032 89B9      		out 0x9,r24
 403:main.c        **** 
 404:main.c        **** #ifdef UART_DOUBLESPEED
 405:main.c        **** 	UART_STATUS = ( 1<<UART_DOUBLE );
 406:main.c        **** #endif
 407:main.c        **** 
 408:main.c        **** 	UART_CTRL = UART_CTRL_DATA;
 258               	.LM23:
 259 0034 88E1      		ldi r24,lo8(24)
 260 0036 8AB9      		out 0xa,r24
 409:main.c        **** 	UART_CTRL2 = UART_CTRL2_DATA;
 262               	.LM24:
 263 0038 86E8      		ldi r24,lo8(-122)
 264 003a 80BD      		out 0x20,r24
 265 003c E0E9      		ldi r30,lo8(-112)
 266 003e F1E0      		ldi r31,lo8(1)
 410:main.c        **** 	
 411:main.c        **** #if defined(START_POWERSAVE)
 412:main.c        **** 	/*
 413:main.c        **** 		This is an adoption of the Butterfly Bootloader startup-sequence.
 414:main.c        **** 		It may look a little strange but separating the login-loop from
 415:main.c        **** 		the main parser-loop gives a lot a possibilities (timeout, sleep-modes
 416:main.c        **** 	    etc.).
 417:main.c        **** 	*/
 418:main.c        **** 	for(;OK;) 
 419:main.c        **** 	{
 420:main.c        **** 		if ((BLPIN & (1<<BLPNUM))) 
 421:main.c        **** 		{
 422:main.c        **** 		// jump to main app if pin is not grounded
 423:main.c        **** 		BLPORT &= ~(1<<BLPNUM);	// set to default
 424:main.c        **** 
 425:main.c        **** 		#ifdef UART_DOUBLESPEED
 426:main.c        **** 			UART_STATUS &= ~( 1<<UART_DOUBLE );
 427:main.c        **** 		#endif
 428:main.c        **** 
 429:main.c        **** 
 430:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 431:main.c        **** 		BIPORT &= ~(1<<BIPNUM);	
 432:main.c        **** 		BIDDR  &= ~(1<<BIPNUM);
 433:main.c        **** 		#endif
 434:main.c        **** 
 435:main.c        **** 		jump_to_app();		// Jump to application sector
 436:main.c        **** 
 437:main.c        **** 		} 
 438:main.c        **** 		else 
 439:main.c        **** 		{
 440:main.c        **** 		val = recvchar();
 441:main.c        **** 		/* ESC */
 442:main.c        **** 			if (val == 0x1B) 
 443:main.c        **** 			{
 444:main.c        **** 				// AVRPROG connection
 445:main.c        **** 				// Wait for signon
 446:main.c        **** 				while (val != 'S')
 447:main.c        **** 				val = recvchar();
 448:main.c        **** 				
 449:main.c        **** 				send_boot();			// Report signon
 450:main.c        **** 				OK = 0;
 451:main.c        **** 			} 
 452:main.c        **** 			else 
 453:main.c        **** 			{
 454:main.c        **** 			sendchar('?');
 455:main.c        **** 			}
 456:main.c        **** 	    }
 457:main.c        **** 		// Power-Save code here
 458:main.c        **** 	}
 459:main.c        **** 
 460:main.c        **** #elif defined(START_SIMPLE)
 461:main.c        **** 	uint16_t cnt = 0;
 462:main.c        **** 	uint16_t cnt_key = 0;
 268               	.LM25:
 269 0040 80E0      		ldi r24,0
 270 0042 90E0      		ldi r25,0
 271               	.L12:
 463:main.c        **** 	
 464:main.c        **** 	for(cnt = 0; cnt < WAIT_VALUE; cnt++)
 465:main.c        **** 	{
 466:main.c        **** 		if ((BLPIN & (1<<BLPNUM)) && (BL_2_PIN & (1<<BL_2_PNUM))) 
 273               	.LM26:
 274 0044 859B      		sbis 0x10,5
 275 0046 00C0      		rjmp .L11
 277               	.LM27:
 278 0048 B799      		sbic 0x16,7
 467:main.c        **** 		{
 468:main.c        **** 			cnt_key++;
 280               	.LM28:
 281 004a 0196      		adiw r24,1
 282               	.L11:
 283               	.LBB36:
 284               	.LBB37:
 286               	.Ltext3:
   1:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #define __HAS_DELAY_CYCLES 1
  40:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  41:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  42:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  43:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  44:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  45:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  46:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  47:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  49:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  51:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  52:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  53:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  54:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  55:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  58:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  59:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  60:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  62:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  64:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  65:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  67:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  68:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  69:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  71:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  73:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  74:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  75:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  76:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  77:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  78:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  79:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  81:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  82:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  84:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  87:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  88:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  89:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  90:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
  92:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  93:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  94:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
  95:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  97:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  98:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 101:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 102:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 103:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 104:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 105:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 106:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 107:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 109:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 110:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 112:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 114:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 115:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 119:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 120:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 123:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 124:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 125:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    the user gets atleast __us microseconds of delay.
 128:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    to round down and round to closest integer.
 131:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 132:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    Also, the backward compatible
 136:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****    required for rounding are not available to the compiler then.
 139:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 140:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 141:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 142:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 143:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 144:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ; 
 145:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 148:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 149:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 155:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 158:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 159:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 160:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 162:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 163:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 288               	.LM29:
 289 004c AFEC      		ldi r26,lo8(1999)
 290 004e B7E0      		ldi r27,hi8(1999)
 291 0050 1197      	1:	sbiw r26,1
 292 0052 01F4      		brne 1b
 293 0054 00C0      		rjmp .
 294 0056 0000      		nop
 295 0058 3197      		sbiw r30,1
 296               	.LBE37:
 297               	.LBE36:
 299               	.Ltext4:
 464:main.c        **** 	{
 301               	.LM30:
 302 005a 01F4      		brne .L12
 469:main.c        **** 		}
 470:main.c        **** 		_delay_ms(1);
 471:main.c        **** 	}
 472:main.c        **** 	if (cnt_key > (WAIT_VALUE - (WAIT_VALUE/2))) 
 304               	.LM31:
 305 005c 893C      		cpi r24,-55
 306 005e 9105      		cpc r25,__zero_reg__
 307 0060 00F0      		brlo .L13
 473:main.c        **** 	{
 474:main.c        **** 		// jump to main app if pin is not grounded
 475:main.c        **** 		BLPORT	  &= ~(1<<BLPNUM);			// set to default	
 309               	.LM32:
 310 0062 9598      		cbi 0x12,5
 476:main.c        **** 		BL_2_PORT &= ~(1<<BL_2_PNUM);		// set to default
 312               	.LM33:
 313 0064 C798      		cbi 0x18,7
 477:main.c        **** 			
 478:main.c        **** 	#ifdef UART_DOUBLESPEED
 479:main.c        **** 		UART_STATUS &= ~( 1<<UART_DOUBLE );
 480:main.c        **** 	#endif
 481:main.c        **** 
 482:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 483:main.c        **** 		BIPORT &= ~(1<<BIPNUM);	
 315               	.LM34:
 316 0066 9598      		cbi 0x12,5
 484:main.c        **** 		BIDDR  &= ~(1<<BIPNUM);
 318               	.LM35:
 319 0068 8D98      		cbi 0x11,5
 485:main.c        **** 		#endif
 486:main.c        **** 
 487:main.c        **** 		jump_to_app();			// Jump to application sector
 321               	.LM36:
 322 006a 0995      		icall
 323               	.L13:
 462:main.c        **** 	
 325               	.LM37:
 326 006c 10E0      		ldi r17,0
 327 006e 612C      		mov r6,__zero_reg__
 328 0070 712C      		mov r7,__zero_reg__
 329               	.LBB38:
 330               	.LBB39:
 332               	.Ltext5:
 453:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 334               	.LM38:
 335 0072 78E1      		ldi r23,lo8(24)
 336 0074 972E      		mov r9,r23
 337 0076 ECE0      		ldi r30,lo8(12)
 338 0078 8E2E      		mov r8,r30
 339               	.LBE39:
 340               	.LBE38:
 341               	.LBB41:
 342               	.LBB42:
 344               	.Ltext6:
 214:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 346               	.LM39:
 347 007a F3E0      		ldi r31,lo8(3)
 348 007c 2F2E      		mov r2,r31
 218:main.c        **** }
 350               	.LM40:
 351 007e 01E1      		ldi r16,lo8(17)
 352 0080 A0E0      		ldi r26,lo8(gBuffer)
 353 0082 AA2E      		mov r10,r26
 354 0084 A0E0      		ldi r26,hi8(gBuffer)
 355 0086 BA2E      		mov r11,r26
 356               	.L14:
 357               	.LBE42:
 358               	.LBE41:
 488:main.c        **** 	}
 489:main.c        **** 
 490:main.c        **** #elif defined(START_WAIT)
 491:main.c        **** 
 492:main.c        **** 	uint16_t cnt = 0;
 493:main.c        **** 
 494:main.c        **** 	while (1) {
 495:main.c        **** 		if (UART_STATUS & (1<<UART_RXREADY))
 496:main.c        **** 			if (UART_DATA == START_WAIT_UARTCHAR)
 497:main.c        **** 				break;
 498:main.c        **** 
 499:main.c        **** 		if (cnt++ >= WAIT_VALUE) {
 500:main.c        **** 			BLPORT &= ~(1<<BLPNUM);		// set to default
 501:main.c        **** 
 502:main.c        **** 
 503:main.c        **** 			#ifdef ENABLE_BOOT_LED	// LED OFF
 504:main.c        **** 			BIPORT &= ~(1<<BIPNUM);	
 505:main.c        **** 			BIDDR  &= ~(1<<BIPNUM);
 506:main.c        **** 			#endif
 507:main.c        **** 			jump_to_app();			// Jump to application sector
 508:main.c        **** 		}
 509:main.c        **** 
 510:main.c        **** 		_delay_ms(10);
 511:main.c        **** 	}
 512:main.c        **** 	send_boot();
 513:main.c        **** 
 514:main.c        **** #elif defined(START_BOOTICE)
 515:main.c        **** #warning "BOOTICE mode - no startup-condition"
 516:main.c        **** 
 517:main.c        **** #else
 518:main.c        **** #error "Select START_ condition for bootloader in main.c"
 519:main.c        **** #endif
 520:main.c        **** 
 521:main.c        **** 
 522:main.c        **** 	for(;;) 
 523:main.c        **** 	{
 524:main.c        **** 		val = recvchar();
 360               	.LM41:
 361 0088 00D0      		rcall recvchar
 525:main.c        **** 		// Autoincrement?
 526:main.c        **** 		if (val == 'a') 
 363               	.LM42:
 364 008a 8136      		cpi r24,lo8(97)
 365 008c 01F4      		brne .L15
 527:main.c        **** 		{
 528:main.c        **** 			sendchar('Y');			// Autoincrement is quicker
 367               	.LM43:
 368 008e 89E5      		ldi r24,lo8(89)
 369 0090 00C0      		rjmp .L62
 370               	.L15:
 529:main.c        **** 
 530:main.c        **** 		//write address
 531:main.c        **** 		} 
 532:main.c        **** 		else if (val == 'A') 
 372               	.LM44:
 373 0092 8134      		cpi r24,lo8(65)
 374 0094 01F4      		brne .L17
 533:main.c        **** 		{
 534:main.c        **** 			address = recvchar();		//read address 8 MSB
 376               	.LM45:
 377 0096 00D0      		rcall recvchar
 378 0098 682E      		mov r6,r24
 379 009a 712C      		mov r7,__zero_reg__
 535:main.c        **** 			address = (address<<8) | recvchar();
 381               	.LM46:
 382 009c 762C      		mov r7,r6
 383 009e 6624      		clr r6
 384 00a0 00D0      		rcall recvchar
 385 00a2 682A      		or r6,r24
 386 00a4 00C0      		rjmp .L63
 387               	.L17:
 536:main.c        **** 			sendchar('\r');
 537:main.c        **** 
 538:main.c        **** 		// Buffer load support
 539:main.c        **** 		} 
 540:main.c        **** 		else if (val == 'b') 
 389               	.LM47:
 390 00a6 8236      		cpi r24,lo8(98)
 391 00a8 01F4      		brne .L18
 541:main.c        **** 		{
 542:main.c        **** 			sendchar('Y');					// Report buffer load supported
 393               	.LM48:
 394 00aa 89E5      		ldi r24,lo8(89)
 395 00ac 00D0      		rcall sendchar
 543:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 397               	.LM49:
 398 00ae 80E0      		ldi r24,0
 399 00b0 00D0      		rcall sendchar
 544:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 401               	.LM50:
 402 00b2 80E4      		ldi r24,lo8(64)
 403 00b4 00C0      		rjmp .L62
 404               	.L18:
 545:main.c        **** 
 546:main.c        **** 		// Start buffer load
 547:main.c        **** 		} 
 548:main.c        **** 		else if (val == 'B') 
 406               	.LM51:
 407 00b6 8234      		cpi r24,lo8(66)
 408 00b8 01F0      		breq .+2
 409 00ba 00C0      		rjmp .L19
 410               	.LBB44:
 549:main.c        **** 		{
 550:main.c        **** 			pagebuf_t size;
 551:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 412               	.LM52:
 413 00bc 00D0      		rcall recvchar
 552:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 415               	.LM53:
 416 00be 00D0      		rcall recvchar
 417 00c0 482E      		mov r4,r24
 553:main.c        **** 			val = recvchar();				// Load memory type ('E' or 'F')
 419               	.LM54:
 420 00c2 00D0      		rcall recvchar
 421 00c4 982F      		mov r25,r24
 422 00c6 50E0      		ldi r21,lo8(gBuffer)
 423 00c8 E52E      		mov r14,r21
 424 00ca 50E0      		ldi r21,hi8(gBuffer)
 425 00cc F52E      		mov r15,r21
 426               	.LBB45:
 427               	.LBB46:
 226:main.c        **** 		{
 429               	.LM55:
 430 00ce D12C      		mov r13,__zero_reg__
 431               	.L21:
 228:main.c        **** 		}
 433               	.LM56:
 434 00d0 D414      		cp r13,r4
 435 00d2 00F4      		brsh .L47
 436 00d4 9983      		std Y+1,r25
 437 00d6 00D0      		rcall recvchar
 438 00d8 9981      		ldd r25,Y+1
 439 00da 00C0      		rjmp .L20
 440               	.L47:
 441 00dc 8FEF      		ldi r24,lo8(-1)
 442               	.L20:
 443 00de F701      		movw r30,r14
 444 00e0 8193      		st Z+,r24
 445 00e2 7F01      		movw r14,r30
 226:main.c        **** 		{
 447               	.LM57:
 448 00e4 D394      		inc r13
 449 00e6 F0E4      		ldi r31,lo8(64)
 450 00e8 DF12      		cpse r13,r31
 451 00ea 00C0      		rjmp .L21
 452               	.LBE46:
 453               	.LBE45:
 554:main.c        **** 			recvBuffer(size);
 555:main.c        **** 
 556:main.c        **** 			if (device == DEVTYPE) 
 455               	.LM58:
 456 00ec 1737      		cpi r17,lo8(119)
 457 00ee 01F0      		breq .+2
 458 00f0 00C0      		rjmp .L64
 557:main.c        **** 			{
 558:main.c        **** 				if (val == 'F') 
 460               	.LM59:
 461 00f2 9634      		cpi r25,lo8(70)
 462 00f4 01F0      		breq .+2
 463 00f6 00C0      		rjmp .L23
 464               	.LBB47:
 465               	.LBB48:
 234:main.c        **** 	uint32_t baddr = pagestart;
 467               	.LM60:
 468 00f8 6301      		movw r12,r6
 469 00fa E12C      		mov r14,__zero_reg__
 470 00fc F12C      		mov r15,__zero_reg__
 471 00fe CC0C      		lsl r12
 472 0100 DD1C      		rol r13
 473 0102 EE1C      		rol r14
 474 0104 FF1C      		rol r15
 237:main.c        **** 
 476               	.LM61:
 477 0106 2091 0000 		lds r18,gBuffer
 235:main.c        **** 	uint16_t data;
 479               	.LM62:
 480 010a B701      		movw r22,r14
 481 010c A601      		movw r20,r12
 237:main.c        **** 
 483               	.LM63:
 484 010e A0E0      		ldi r26,lo8(gBuffer)
 485 0110 B0E0      		ldi r27,hi8(gBuffer)
 486               	.L25:
 487 0112 1296      		adiw r26,2
 488 0114 FD01      		movw r30,r26
 489 0116 3197      		sbiw r30,1
 242:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 491               	.LM64:
 492 0118 8081      		ld r24,Z
 493 011a 30E0      		ldi r19,0
 494 011c 382B      		or r19,r24
 243:main.c        **** 
 496               	.LM65:
 497 011e 81E0      		ldi r24,lo8(1)
 498 0120 FA01      		movw r30,r20
 499               	/* #APP */
 500               	 ;  243 "main.c" 1
 501 0122 0901      		movw  r0, r18
 502 0124 8093 5700 		sts 87, r24
 503 0128 E895      		spm
 504 012a 1124      		clr  r1
 505               		
 506               	 ;  0 "" 2
 245:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 508               	.LM66:
 509               	/* #NOAPP */
 510 012c 4E5F      		subi r20,-2
 511 012e 5F4F      		sbci r21,-1
 512 0130 6F4F      		sbci r22,-1
 513 0132 7F4F      		sbci r23,-1
 514 0134 8A2D      		mov r24,r10
 515 0136 8A1B      		sub r24,r26
 516 0138 840D      		add r24,r4
 248:main.c        **** 
 518               	.LM67:
 519 013a 01F0      		breq .L24
 242:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 521               	.LM68:
 522 013c 2C91      		ld r18,X
 523 013e 00C0      		rjmp .L25
 524               	.L24:
 250:main.c        **** 	boot_spm_busy_wait();
 526               	.LM69:
 527 0140 85E0      		ldi r24,lo8(5)
 528 0142 F601      		movw r30,r12
 529               	/* #APP */
 530               	 ;  250 "main.c" 1
 531 0144 8093 5700 		sts 87, r24
 532 0148 E895      		spm
 533               		
 534               	 ;  0 "" 2
 535               	/* #NOAPP */
 536               	.L26:
 251:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 538               	.LM70:
 539 014a 07B6      		in __tmp_reg__,0x37
 540 014c 00FC      		sbrc __tmp_reg__,0
 541 014e 00C0      		rjmp .L26
 252:main.c        **** 
 543               	.LM71:
 544               	/* #APP */
 545               	 ;  252 "main.c" 1
 546 0150 0093 5700 		sts 87, r16
 547 0154 E895      		spm
 548               		
 549               	 ;  0 "" 2
 254:main.c        **** }
 551               	.LM72:
 552               	/* #NOAPP */
 553 0156 DB01      		movw r26,r22
 554 0158 CA01      		movw r24,r20
 555 015a B695      		lsr r27
 556 015c A795      		ror r26
 557 015e 9795      		ror r25
 558 0160 8795      		ror r24
 559 0162 3C01      		movw r6,r24
 560               	.LBE48:
 561               	.LBE47:
 562 0164 00C0      		rjmp .L63
 563               	.L23:
 559:main.c        **** 				{
 560:main.c        **** 				address = writeFlashPage(address, size);
 561:main.c        **** 				} 
 562:main.c        **** 				else if (val == 'E') 
 565               	.LM73:
 566 0166 9534      		cpi r25,lo8(69)
 567 0168 01F0      		breq .+2
 568 016a 00C0      		rjmp .L63
 569 016c 20E0      		ldi r18,lo8(gBuffer)
 570 016e E22E      		mov r14,r18
 571 0170 20E0      		ldi r18,hi8(gBuffer)
 572 0172 F22E      		mov r15,r18
 573 0174 6301      		movw r12,r6
 574 0176 342C      		mov r3,r4
 575 0178 3A0C      		add r3,r10
 576               	.L28:
 577               	.LBB49:
 578               	.LBB50:
 263:main.c        **** 		address++;			// Select next byte
 580               	.LM74:
 581 017a D701      		movw r26,r14
 582 017c 6D91      		ld r22,X+
 583 017e 7D01      		movw r14,r26
 584 0180 C601      		movw r24,r12
 585 0182 00D0      		rcall eeprom_write_byte
 264:main.c        **** 		size--;				// Decreas number of bytes to write
 587               	.LM75:
 588 0184 BFEF      		ldi r27,-1
 589 0186 CB1A      		sub r12,r27
 590 0188 DB0A      		sbc r13,r27
 267:main.c        **** 
 592               	.LM76:
 593 018a 3E10      		cpse r3,r14
 594 018c 00C0      		rjmp .L28
 595 018e EFEF      		ldi r30,-1
 596 0190 6E1A      		sub r6,r30
 597 0192 7E0A      		sbc r7,r30
 598 0194 8FEF      		ldi r24,lo8(-1)
 599 0196 840D      		add r24,r4
 600 0198 680E      		add r6,r24
 601 019a 711C      		adc r7,__zero_reg__
 602 019c 00C0      		rjmp .L63
 603               	.L19:
 604               	.LBE50:
 605               	.LBE49:
 606               	.LBE44:
 563:main.c        **** 				{
 564:main.c        **** 				address = writeEEpromPage(address, size);
 565:main.c        **** 				}
 566:main.c        **** 				sendchar('\r');
 567:main.c        **** 			} 
 568:main.c        **** 			else 
 569:main.c        **** 			{
 570:main.c        **** 			sendchar(0);
 571:main.c        **** 			}
 572:main.c        **** 
 573:main.c        **** 		// Block read
 574:main.c        **** 		} 
 575:main.c        **** 		else if (val == 'g') 
 608               	.LM77:
 609 019e 8736      		cpi r24,lo8(103)
 610 01a0 01F0      		breq .+2
 611 01a2 00C0      		rjmp .L29
 612               	.LBB51:
 576:main.c        **** 		{
 577:main.c        **** 			pagebuf_t size;
 578:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 614               	.LM78:
 615 01a4 00D0      		rcall recvchar
 579:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 617               	.LM79:
 618 01a6 00D0      		rcall recvchar
 619 01a8 F82E      		mov r15,r24
 580:main.c        **** 			val = recvchar();				// Get memtype
 621               	.LM80:
 622 01aa 00D0      		rcall recvchar
 581:main.c        **** 
 582:main.c        **** 			if (val == 'F') 
 624               	.LM81:
 625 01ac 8634      		cpi r24,lo8(70)
 626 01ae 01F4      		brne .L30
 627               	.LBB52:
 628               	.LBB53:
 276:main.c        **** 	uint16_t data;
 630               	.LM82:
 631 01b0 A301      		movw r20,r6
 632 01b2 60E0      		ldi r22,0
 633 01b4 70E0      		ldi r23,0
 634 01b6 2A01      		movw r4,r20
 635 01b8 3B01      		movw r6,r22
 636 01ba 440C      		lsl r4
 637 01bc 551C      		rol r5
 638 01be 661C      		rol r6
 639 01c0 771C      		rol r7
 640 01c2 DF2C      		mov r13,r15
 641 01c4 D40C      		add r13,r4
 642               	.L31:
 643               	.LBB54:
 288:main.c        **** 	#endif
 645               	.LM83:
 646 01c6 F201      		movw r30,r4
 647               	/* #APP */
 648               	 ;  288 "main.c" 1
 649 01c8 E590      		lpm r14, Z+
 650 01ca F490      		lpm r15, Z
 651               		
 652               	 ;  0 "" 2
 653               	/* #NOAPP */
 654               	.LBE54:
 306:main.c        **** 		sendchar((data >> 8));		// send MSB
 656               	.LM84:
 657 01cc 8E2D      		mov r24,r14
 658 01ce 00D0      		rcall sendchar
 307:main.c        **** 		baddr += 2;			// Select next word in memory
 660               	.LM85:
 661 01d0 8F2D      		mov r24,r15
 662 01d2 00D0      		rcall sendchar
 308:main.c        **** 		size -= 2;			// Subtract two bytes from number of bytes to read
 664               	.LM86:
 665 01d4 F2E0      		ldi r31,2
 666 01d6 4F0E      		add r4,r31
 667 01d8 511C      		adc r5,__zero_reg__
 668 01da 611C      		adc r6,__zero_reg__
 669 01dc 711C      		adc r7,__zero_reg__
 311:main.c        **** 	return baddr>>1;
 671               	.LM87:
 672 01de D410      		cpse r13,r4
 673 01e0 00C0      		rjmp .L31
 312:main.c        **** }
 675               	.LM88:
 676 01e2 B301      		movw r22,r6
 677 01e4 A201      		movw r20,r4
 678 01e6 7695      		lsr r23
 679 01e8 6795      		ror r22
 680 01ea 5795      		ror r21
 681 01ec 4795      		ror r20
 682 01ee 3A01      		movw r6,r20
 683               	.LBE53:
 684               	.LBE52:
 685 01f0 00C0      		rjmp .L14
 686               	.L30:
 583:main.c        **** 			{
 584:main.c        **** 			address = readFlashPage(address, size);
 585:main.c        **** 			} 
 586:main.c        **** 			else if (val == 'E') 
 688               	.LM89:
 689 01f2 8534      		cpi r24,lo8(69)
 690 01f4 01F0      		breq .+2
 691 01f6 00C0      		rjmp .L14
 692 01f8 6301      		movw r12,r6
 693 01fa E62C      		mov r14,r6
 694 01fc EF0C      		add r14,r15
 695               	.L32:
 696               	.LBB55:
 697               	.LBB56:
 319:main.c        **** 	address++;
 699               	.LM90:
 700 01fe C601      		movw r24,r12
 701 0200 00D0      		rcall eeprom_read_byte
 702 0202 00D0      		rcall sendchar
 320:main.c        **** 	size--;				// Decrease number of bytes to read
 704               	.LM91:
 705 0204 8FEF      		ldi r24,-1
 706 0206 C81A      		sub r12,r24
 707 0208 D80A      		sbc r13,r24
 323:main.c        **** 
 709               	.LM92:
 710 020a EC10      		cpse r14,r12
 711 020c 00C0      		rjmp .L32
 712 020e AFEF      		ldi r26,-1
 713 0210 6A1A      		sub r6,r26
 714 0212 7A0A      		sbc r7,r26
 715 0214 FA94      		dec r15
 716 0216 6F0C      		add r6,r15
 717 0218 711C      		adc r7,__zero_reg__
 718 021a 00C0      		rjmp .L14
 719               	.L29:
 720               	.LBE56:
 721               	.LBE55:
 722               	.LBE51:
 587:main.c        **** 			{
 588:main.c        **** 			address = readEEpromPage(address, size);
 589:main.c        **** 			}
 590:main.c        **** 
 591:main.c        **** 		// Chip erase
 592:main.c        ****  		} 
 593:main.c        **** 		else if (val == 'e') 
 724               	.LM93:
 725 021c 8536      		cpi r24,lo8(101)
 726 021e 01F4      		brne .L33
 594:main.c        **** 		{
 595:main.c        **** 		if (device == DEVTYPE) 
 728               	.LM94:
 729 0220 1737      		cpi r17,lo8(119)
 730 0222 01F0      		breq .+2
 731 0224 00C0      		rjmp .L63
 732 0226 E0E0      		ldi r30,0
 733 0228 F0E0      		ldi r31,0
 734               	.L36:
 735               	.LBB57:
 736               	.LBB43:
 214:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 738               	.LM95:
 739               	/* #APP */
 740               	 ;  214 "main.c" 1
 741 022a 2092 5700 		sts 87, r2
 742 022e E895      		spm
 743               		
 744               	 ;  0 "" 2
 745               	/* #NOAPP */
 746               	.L35:
 215:main.c        **** 		addr += SPM_PAGESIZE;
 748               	.LM96:
 749 0230 07B6      		in __tmp_reg__,0x37
 750 0232 00FC      		sbrc __tmp_reg__,0
 751 0234 00C0      		rjmp .L35
 752 0236 E05C      		subi r30,-64
 753 0238 FF4F      		sbci r31,-1
 212:main.c        **** 		{
 755               	.LM97:
 756 023a E115      		cp r30,__zero_reg__
 757 023c BCE1      		ldi r27,28
 758 023e FB07      		cpc r31,r27
 759 0240 01F4      		brne .L36
 218:main.c        **** }
 761               	.LM98:
 762               	/* #APP */
 763               	 ;  218 "main.c" 1
 764 0242 0093 5700 		sts 87, r16
 765 0246 E895      		spm
 766               		
 767               	 ;  0 "" 2
 768               	/* #NOAPP */
 769 0248 00C0      		rjmp .L63
 770               	.L33:
 771               	.LBE43:
 772               	.LBE57:
 596:main.c        **** 			{
 597:main.c        **** 			eraseFlash();
 598:main.c        **** 			}
 599:main.c        **** 		sendchar('\r');
 600:main.c        **** 
 601:main.c        **** 		// Exit upgrade
 602:main.c        **** 		} 
 603:main.c        **** 		else if (val == 'E') 
 774               	.LM99:
 775 024a 8534      		cpi r24,lo8(69)
 776 024c 01F4      		brne .L37
 777               	.LBB58:
 778               	.LBB40:
 780               	.Ltext7:
 453:e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 782               	.LM100:
 783               	/* #APP */
 784               	 ;  453 "e:\program files (x86)\atmel\studio\7.0\toolchain\avr8\avr8-gnu-toolchain\avr\include\avr\
 785 024e 0FB6      		in __tmp_reg__,__SREG__
 786 0250 F894      		cli
 787 0252 A895      		wdr
 788 0254 91BC      		out 33, r9
 789 0256 0FBE      		out __SREG__,__tmp_reg__
 790 0258 81BC      		out 33, r8
 791               	 	
 792               	 ;  0 "" 2
 793               	/* #NOAPP */
 794 025a 00C0      		rjmp .L63
 795               	.L37:
 796               	.LBE40:
 797               	.LBE58:
 799               	.Ltext8:
 604:main.c        **** 		{
 605:main.c        **** 		wdt_enable(EXIT_WDT_TIME); // Enable Watchdog Timer to give reset
 606:main.c        **** 		sendchar('\r');
 607:main.c        **** 
 608:main.c        **** 		#ifdef WRITELOCKBITS
 609:main.c        **** 			#warning "Extension 'WriteLockBits' enabled"
 610:main.c        **** 			// TODO: does not work reliably
 611:main.c        **** 			// write lockbits
 612:main.c        **** 			} 
 613:main.c        **** 			else if (val == 'l') 
 614:main.c        **** 			{
 615:main.c        **** 			if (device == DEVTYPE) 
 616:main.c        **** 				{
 617:main.c        **** 				// write_lock_bits(recvchar());
 618:main.c        **** 				boot_lock_bits_set(recvchar());	// boot.h takes care of mask
 619:main.c        **** 				boot_spm_busy_wait();
 620:main.c        **** 				}
 621:main.c        **** 			sendchar('\r');
 622:main.c        **** 		#endif
 623:main.c        **** 		// Enter programming mode
 624:main.c        **** 		} 
 625:main.c        **** 		else if (val == 'P') 
 801               	.LM101:
 802 025c 8035      		cpi r24,lo8(80)
 803 025e 01F0      		breq .L63
 626:main.c        **** 		{
 627:main.c        **** 		sendchar('\r');
 628:main.c        **** 
 629:main.c        **** 		// Leave programming mode
 630:main.c        **** 		} 
 631:main.c        **** 		else if (val == 'L') 
 805               	.LM102:
 806 0260 8C34      		cpi r24,lo8(76)
 807 0262 01F0      		breq .L63
 632:main.c        **** 		{
 633:main.c        **** 		sendchar('\r');
 634:main.c        **** 		// return programmer type
 635:main.c        **** 		} 
 636:main.c        **** 		else if (val == 'p') 
 809               	.LM103:
 810 0264 8037      		cpi r24,lo8(112)
 811 0266 01F4      		brne .L40
 637:main.c        **** 		{
 638:main.c        **** 		sendchar('S');		// always serial programmer
 813               	.LM104:
 814 0268 83E5      		ldi r24,lo8(83)
 815 026a 00C0      		rjmp .L62
 816               	.L40:
 639:main.c        **** 
 640:main.c        **** 		#ifdef ENABLEREADFUSELOCK
 641:main.c        **** 			#warning "Extension 'ReadFuseLock' enabled"
 642:main.c        **** 			// read "low" fuse bits
 643:main.c        **** 			} 
 644:main.c        **** 			else if (val == 'F') 
 645:main.c        **** 			{
 646:main.c        **** 			sendchar(read_fuse_lock(GET_LOW_FUSE_BITS));
 647:main.c        **** 
 648:main.c        **** 			// read lock bits
 649:main.c        **** 			} 
 650:main.c        **** 			else if (val == 'r') 
 651:main.c        **** 			{
 652:main.c        **** 			sendchar(read_fuse_lock(GET_LOCK_BITS));
 653:main.c        **** 
 654:main.c        **** 			// read high fuse bits
 655:main.c        **** 			} 
 656:main.c        **** 			else if (val == 'N') 
 657:main.c        **** 			{
 658:main.c        **** 			sendchar(read_fuse_lock(GET_HIGH_FUSE_BITS));
 659:main.c        **** 			// read extended fuse bits
 660:main.c        **** 			} 
 661:main.c        **** 			else if (val == 'Q') 
 662:main.c        **** 			{
 663:main.c        **** 			sendchar(read_fuse_lock(GET_EXTENDED_FUSE_BITS));
 664:main.c        **** 			#endif
 665:main.c        **** 
 666:main.c        **** 		// Return device type
 667:main.c        **** 		} 
 668:main.c        **** 		else if (val == 't') 
 818               	.LM105:
 819 026c 8437      		cpi r24,lo8(116)
 820 026e 01F4      		brne .L41
 669:main.c        **** 		{
 670:main.c        **** 		sendchar(DEVTYPE);
 822               	.LM106:
 823 0270 87E7      		ldi r24,lo8(119)
 824 0272 00D0      		rcall sendchar
 825               	.L64:
 671:main.c        **** 		sendchar(0);
 827               	.LM107:
 828 0274 80E0      		ldi r24,0
 829 0276 00C0      		rjmp .L62
 830               	.L41:
 672:main.c        **** 		// clear and set LED ignored
 673:main.c        **** 		} 
 674:main.c        **** 		else if ((val == 'x') || (val == 'y')) 
 832               	.LM108:
 833 0278 98E8      		ldi r25,lo8(-120)
 834 027a 980F      		add r25,r24
 835 027c 9230      		cpi r25,lo8(2)
 836 027e 00F4      		brsh .L42
 675:main.c        **** 		{
 676:main.c        **** 		recvchar();
 838               	.LM109:
 839 0280 00D0      		rcall recvchar
 840 0282 00C0      		rjmp .L63
 841               	.L42:
 677:main.c        **** 		sendchar('\r');
 678:main.c        **** 
 679:main.c        **** 		// set device
 680:main.c        **** 		} 
 681:main.c        **** 		else if (val == 'T') 
 843               	.LM110:
 844 0284 8435      		cpi r24,lo8(84)
 845 0286 01F4      		brne .L43
 682:main.c        **** 		{
 683:main.c        **** 		device = recvchar();
 847               	.LM111:
 848 0288 00D0      		rcall recvchar
 849 028a 182F      		mov r17,r24
 850               	.L63:
 684:main.c        **** 		sendchar('\r');
 852               	.LM112:
 853 028c 8DE0      		ldi r24,lo8(13)
 854 028e 00C0      		rjmp .L62
 855               	.L43:
 685:main.c        **** 		// Return software identifier
 686:main.c        **** 		} 
 687:main.c        **** 		else if (val == 'S') 
 857               	.LM113:
 858 0290 8335      		cpi r24,lo8(83)
 859 0292 01F4      		brne .L44
 860               	.LBB59:
 861               	.LBB60:
 352:main.c        **** 	sendchar('V');
 863               	.LM114:
 864 0294 81E4      		ldi r24,lo8(65)
 865 0296 00D0      		rcall sendchar
 353:main.c        **** 	sendchar('R');
 867               	.LM115:
 868 0298 86E5      		ldi r24,lo8(86)
 869 029a 00D0      		rcall sendchar
 354:main.c        **** 	sendchar('B');
 871               	.LM116:
 872 029c 82E5      		ldi r24,lo8(82)
 873 029e 00D0      		rcall sendchar
 355:main.c        **** 	sendchar('O');
 875               	.LM117:
 876 02a0 82E4      		ldi r24,lo8(66)
 877 02a2 00D0      		rcall sendchar
 356:main.c        **** 	sendchar('O');
 879               	.LM118:
 880 02a4 8FE4      		ldi r24,lo8(79)
 881 02a6 00D0      		rcall sendchar
 357:main.c        **** 	sendchar('T');
 883               	.LM119:
 884 02a8 8FE4      		ldi r24,lo8(79)
 885 02aa 00D0      		rcall sendchar
 358:main.c        **** }
 887               	.LM120:
 888 02ac 84E5      		ldi r24,lo8(84)
 889 02ae 00C0      		rjmp .L62
 890               	.L44:
 891               	.LBE60:
 892               	.LBE59:
 688:main.c        **** 		{
 689:main.c        **** 		send_boot();
 690:main.c        **** 
 691:main.c        **** 		// Return Software Version
 692:main.c        **** 		} 
 693:main.c        **** 		else if (val == 'V') {
 894               	.LM121:
 895 02b0 8635      		cpi r24,lo8(86)
 896 02b2 01F4      		brne .L45
 694:main.c        **** 		sendchar(VERSION_HIGH);
 898               	.LM122:
 899 02b4 80E3      		ldi r24,lo8(48)
 900 02b6 00D0      		rcall sendchar
 695:main.c        **** 		sendchar(VERSION_LOW);
 902               	.LM123:
 903 02b8 88E3      		ldi r24,lo8(56)
 904 02ba 00C0      		rjmp .L62
 905               	.L45:
 696:main.c        **** 
 697:main.c        **** 		// Return Signature Bytes (it seems that 
 698:main.c        **** 		// AVRProg expects the "Atmel-byte" 0x1E last
 699:main.c        **** 		// but shows it first in the dialog-window)
 700:main.c        **** 		} 
 701:main.c        **** 		else if (val == 's') 
 907               	.LM124:
 908 02bc 8337      		cpi r24,lo8(115)
 909 02be 01F4      		brne .L46
 702:main.c        **** 		{
 703:main.c        **** 		sendchar(SIG_BYTE3);
 911               	.LM125:
 912 02c0 87E0      		ldi r24,lo8(7)
 913 02c2 00D0      		rcall sendchar
 704:main.c        **** 		sendchar(SIG_BYTE2);
 915               	.LM126:
 916 02c4 83E9      		ldi r24,lo8(-109)
 917 02c6 00D0      		rcall sendchar
 705:main.c        **** 		sendchar(SIG_BYTE1);
 919               	.LM127:
 920 02c8 8EE1      		ldi r24,lo8(30)
 921 02ca 00C0      		rjmp .L62
 922               	.L46:
 706:main.c        **** 
 707:main.c        **** 		/* ESC */
 708:main.c        **** 		} 
 709:main.c        **** 		else if(val != 0x1b) 
 924               	.LM128:
 925 02cc 8B31      		cpi r24,lo8(27)
 926 02ce 01F4      		brne .+2
 927 02d0 00C0      		rjmp .L14
 710:main.c        **** 		{
 711:main.c        **** 		sendchar('?');
 929               	.LM129:
 930 02d2 8FE3      		ldi r24,lo8(63)
 931               	.L62:
 932 02d4 00D0      		rcall sendchar
 933 02d6 00C0      		rjmp .L14
 948               	.Lscope4:
 949               		.comm	gBuffer,64,1
 951               		.text
 953               	.Letext0:
 954               		.ident	"GCC: (AVR_8_bit_GNU_Toolchain_3.5.1_1671) 4.9.2"
 955               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
  E:\Temp\ccGWSWEw.s:2      *ABS*:0000003e __SP_H__
  E:\Temp\ccGWSWEw.s:3      *ABS*:0000003d __SP_L__
  E:\Temp\ccGWSWEw.s:4      *ABS*:0000003f __SREG__
  E:\Temp\ccGWSWEw.s:5      *ABS*:00000000 __tmp_reg__
  E:\Temp\ccGWSWEw.s:6      *ABS*:00000001 __zero_reg__
  E:\Temp\ccGWSWEw.s:116    .text:00000000 sendchar
  E:\Temp\ccGWSWEw.s:137    .text:00000008 recvchar
  E:\Temp\ccGWSWEw.s:161    .text:00000010 __vector_default
  E:\Temp\ccGWSWEw.s:176    .text.startup:00000000 main
                            *COM*:00000040 gBuffer

UNDEFINED SYMBOLS
eeprom_write_byte
eeprom_read_byte
__do_clear_bss
